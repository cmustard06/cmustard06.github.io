<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>网络编程 | glamor的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="socket编程在python中我们如果需要编程网络编程的时候，需要以下几个步骤  建立socket，使用socket函数 绑定socket，使用bind函数">
<meta name="keywords" content="golang,编程">
<meta property="og:type" content="article">
<meta property="og:title" content="网络编程">
<meta property="og:url" content="http://www.cmustarc.com/2018/01/03/网络编程/index.html">
<meta property="og:site_name" content="glamor的博客">
<meta property="og:description" content="socket编程在python中我们如果需要编程网络编程的时候，需要以下几个步骤  建立socket，使用socket函数 绑定socket，使用bind函数">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/6853514-9ea8b1984dbac948.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-01-03T13:20:50.729Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="网络编程">
<meta name="twitter:description" content="socket编程在python中我们如果需要编程网络编程的时候，需要以下几个步骤  建立socket，使用socket函数 绑定socket，使用bind函数">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/6853514-9ea8b1984dbac948.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternative" href="/atom.xml" title="glamor的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate">glamor</a></h1>
        </hgroup>

        
        <p class="header-subtitle">莫等闲，白了少年头空悲切...</p>
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">博客首页</a></li>
                        
                            <li><a href="/categories/python">人生苦短</a></li>
                        
                            <li><a href="/categories/Web安全">安全海洋</a></li>
                        
                            <li><a href="/categories/notes">随笔</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="mailto:root@cmustard.com" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/cmustard06" title="github">github</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP/IP</a> <a href="/tags/go/" style="font-size: 10px;">go</a> <a href="/tags/golang/" style="font-size: 17.5px;">golang</a> <a href="/tags/importlib/" style="font-size: 10px;">importlib</a> <a href="/tags/poc/" style="font-size: 12.5px;">poc</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/python3/" style="font-size: 12.5px;">python3</a> <a href="/tags/sql注入/" style="font-size: 10px;">sql注入</a> <a href="/tags/struct/" style="font-size: 10px;">struct</a> <a href="/tags/struts/" style="font-size: 10px;">struts</a> <a href="/tags/tcp/" style="font-size: 10px;">tcp</a> <a href="/tags/tcp-ip/" style="font-size: 10px;">tcp/ip</a> <a href="/tags/windows命令/" style="font-size: 10px;">windows命令</a> <a href="/tags/事件驱动/" style="font-size: 10px;">事件驱动</a> <a href="/tags/代理/" style="font-size: 10px;">代理</a> <a href="/tags/博客/" style="font-size: 10px;">博客</a> <a href="/tags/基础/" style="font-size: 15px;">基础</a> <a href="/tags/并发/" style="font-size: 10px;">并发</a> <a href="/tags/异步IO/" style="font-size: 10px;">异步IO</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/漏扫/" style="font-size: 12.5px;">漏扫</a> <a href="/tags/爬虫/" style="font-size: 10px;">爬虫</a> <a href="/tags/科学上网/" style="font-size: 10px;">科学上网</a> <a href="/tags/系统/" style="font-size: 10px;">系统</a> <a href="/tags/编程/" style="font-size: 15px;">编程</a> <a href="/tags/编程语言/" style="font-size: 12.5px;">编程语言</a> <a href="/tags/网络/" style="font-size: 12.5px;">网络</a> <a href="/tags/网络基础知识/" style="font-size: 10px;">网络基础知识</a> <a href="/tags/网络编程/" style="font-size: 10px;">网络编程</a> <a href="/tags/集合/" style="font-size: 10px;">集合</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.dmmjy9.top">dmmjy9</a>
                    
                    </div>
                </section>
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">glamor</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">glamor</a></h1>
            </hgroup>
            
            <p class="header-subtitle">莫等闲，白了少年头空悲切...</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">博客首页</a></li>
                
                    <li><a href="/categories/python">人生苦短</a></li>
                
                    <li><a href="/categories/Web安全">安全海洋</a></li>
                
                    <li><a href="/categories/notes">随笔</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="mailto:root@cmustard.com" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/cmustard06" title="github">github</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-网络编程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/03/网络编程/" class="article-date">
      <time datetime="2018-01-03T13:20:50.729Z" itemprop="datePublished">2018-01-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      网络编程
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/notes/">notes</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编程/">编程</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h1><p>在python中我们如果需要编程网络编程的时候，需要以下几个步骤</p>
<ul>
<li>建立socket，使用socket函数</li>
<li>绑定socket，使用bind函数<a id="more"></a></li>
<li>监听，使用listen函数，或者连接，使用connnet函数</li>
<li>接收连接，使用accept函数</li>
<li>接收数据，使用receive函数，或者发送数据，使用send函数<br><strong>在go语言中我们只需要调用<code>net.Dial()</code>即可</strong></li>
</ul>
<h2 id="Dial-函数"><a href="#Dial-函数" class="headerlink" title="Dial()函数"></a>Dial()函数</h2><p><strong>Dial()函数的原型如下</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func Dial(net, addr string) (Conn, error)</div></pre></td></tr></table></figure></p>
<p>其中net参数是网络协议的名字，addr参数是Ip地址或者域名，端口号以”:”的形式跟随在地址或者域名后面，如果连接成功，返回连接对象，否则返回error<br>常见的几种协议的调用方式</p>
<h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">conn, err := net.Dial(<span class="string">"tcp"</span>,<span class="string">"192.168.0.10:2100"</span>)</div></pre></td></tr></table></figure>
<h3 id="UDP连接"><a href="#UDP连接" class="headerlink" title="UDP连接"></a>UDP连接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">conn,err := net.Dial(<span class="string">"udp"</span>,<span class="string">"192.168.0.12:975"</span>)</div></pre></td></tr></table></figure>
<h3 id="ICMP连接"><a href="#ICMP连接" class="headerlink" title="ICMP连接"></a>ICMP连接</h3><p>（使用协议名称）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">conn,err := net.Dial(<span class="string">"ip4:icmp"</span>,<span class="string">"www.baidu.com"</span>)</div></pre></td></tr></table></figure></p>
<p>(使用协议编号)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">conn,err := net.Dial(<span class="string">"ip4:1"</span>,<span class="string">"10.0.0.3"</span>)</div></pre></td></tr></table></figure></p>
<p><a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xml" target="_blank" rel="external">协议编号查询</a></p>
<p>目前Dial函数支持如下几种网络协议，tcp，tcp4（仅限IPv4），tcp6（仅限IPV6），udp，udp4，udp6，ipv6，ip，ip4，ip6,。<br>在成功建立连接之后，我们可以进行数据的发送和接收，使用conn的Write()发送数据，使用Read()接收数据</p>
<h2 id="TCP示例程序"><a href="#TCP示例程序" class="headerlink" title="TCP示例程序"></a>TCP示例程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import(</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"net"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"io"</span></div><div class="line">	<span class="string">"bytes"</span></div><div class="line">)</div><div class="line"></div><div class="line">func checkError(err error)&#123;</div><div class="line">	<span class="keyword">if</span> err!=nil&#123;</div><div class="line">		fmt.Fprint(os.Stderr,<span class="string">"Get a error:"</span>,err.Error())</div><div class="line">		os.Exit(1)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func readFully(conn net.Conn) ([]byte,error)&#123;</div><div class="line">	// 出现异常执行这段代码</div><div class="line">	defer conn.Close()</div><div class="line">	var buf [512]byte</div><div class="line"></div><div class="line">	// 创建一个空缓冲区</div><div class="line">	result := bytes.NewBuffer(nil)</div><div class="line">	//start := 0</div><div class="line">	//temp := make([]byte,1000)</div><div class="line">	<span class="keyword">for</span>&#123;</div><div class="line">		n, err:= conn.Read(buf[0:])</div><div class="line">		//将获得的数据写入到缓冲区</div><div class="line">		result.Write(buf[0:n])</div><div class="line">		//j:=0</div><div class="line">		//<span class="keyword">for</span> i:=start;i&lt;start+n;i++&#123;</div><div class="line">		//	temp[i] = buf[j]</div><div class="line">		//	j++</div><div class="line">		//&#125;</div><div class="line">		//</div><div class="line">		//start = start+n</div><div class="line">		<span class="keyword">if</span> err != nil &#123;</div><div class="line">			//如果返回的错误为EOF，说明数据接受完成</div><div class="line">			<span class="keyword">if</span> err == io.EOF &#123;</div><div class="line">				<span class="built_in">break</span></div><div class="line">			&#125;</div><div class="line">			//否则就返回nil，与错误</div><div class="line">			<span class="built_in">return</span> nil, err</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	//fmt.Println(temp)</div><div class="line">	//fmt.Println(string(temp))</div><div class="line">	fmt.Println(result)</div><div class="line">	//返回缓冲区中尚未读取的字节数组</div><div class="line">	<span class="built_in">return</span>  result.Bytes(),nil</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">func <span class="function"><span class="title">main</span></span>()&#123;</div><div class="line">	<span class="keyword">if</span> len(os.Args) !=2&#123;</div><div class="line">		fmt.Fprint(os.Stderr,<span class="string">"input error:"</span>,os.Args[0],<span class="string">" host:port"</span>)</div><div class="line">		os.Exit(1)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	service := os.Args[1]</div><div class="line"></div><div class="line">	conn,err:=net.Dial(<span class="string">"tcp"</span>,service)</div><div class="line">	checkError(err)</div><div class="line"></div><div class="line">	_,err = conn.Write([]byte(<span class="string">"HEAD / HTTP/1.0\r\nHOST:www.baidu.com\r\n\r\n"</span>))</div><div class="line">	checkError(err)</div><div class="line">	result,err := readFully(conn)</div><div class="line">	checkError(err)</div><div class="line"></div><div class="line">	fmt.Println(string(result))</div><div class="line">	os.Exit(0)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p><code>Dial()</code>函数是对<code>DialTCP()</code>,<code>DialUDP()</code>,<code>DialIP</code>,和<code>DialUnix()</code>的封装，我们也可以直接调用这些函数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">func DialTCP(net string, laddr, raddr *TCPAddr) (c *TCPConn, err error)</div><div class="line">func DialUDP(net string, laddr, raddr *UDPAddr) (c *UDPConn, err error)</div><div class="line">func DialIP(netProto string, laddr, raddr *IPAddr) (*IPConn, error)</div><div class="line">func DialUnix(net string, laddr, raddr *UnixAddr) (c *UnixConn, err error)</div></pre></td></tr></table></figure></p>
<h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import(</div><div class="line">	<span class="string">"net"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	//<span class="string">"io/ioutil"</span></div><div class="line">	<span class="string">"io/ioutil"</span></div><div class="line">)</div><div class="line"></div><div class="line">func checkError(err error)&#123;</div><div class="line">	<span class="keyword">if</span> err != nil&#123;</div><div class="line">		fmt.Fprint(os.Stderr,<span class="string">"Get a error"</span>, err.Error())</div><div class="line">		os.Exit(1)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func <span class="function"><span class="title">main</span></span>()&#123;</div><div class="line">	<span class="keyword">if</span> len(os.Args) !=2&#123;</div><div class="line">		fmt.Println(<span class="string">"Usage: "</span>,os.Args[0],<span class="string">" host:port"</span>)</div><div class="line">		os.Exit(1)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	service := os.Args[1]</div><div class="line">	//地址解析</div><div class="line">	tcpIp,err := net.ResolveTCPAddr(<span class="string">"tcp4"</span>,service)</div><div class="line">	checkError(err)</div><div class="line"></div><div class="line">	//连接</div><div class="line">	conn,err:= net.DialTCP(<span class="string">"tcp"</span>,nil,tcpIp)</div><div class="line">	checkError(err)</div><div class="line">	defer conn.Close()</div><div class="line"></div><div class="line">	//发送数据</div><div class="line">	data := <span class="string">"HEAD / HTTP/1.0\r\nHOST:"</span>+service+<span class="string">"\r\n\r\n"</span></div><div class="line">	//将字符串转换成字节数组</div><div class="line">	fmt.Println([]byte(data))</div><div class="line"></div><div class="line">	_,err = conn.Write([]byte(data))</div><div class="line">	checkError(err)</div><div class="line"></div><div class="line">	//接受数据</div><div class="line">	result,err := ioutil.ReadAll(conn)</div><div class="line">	checkError(err)</div><div class="line"></div><div class="line">	fmt.Println(string(result))</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>net包中还包含了一系列的工具函数</p>
<ul>
<li><p>验证Ip的有效性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func net.ParseIP()</div></pre></td></tr></table></figure>
</li>
<li><p>创建子网掩码的代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func IPv4Mask(a,b,c,d byte) IPMask</div></pre></td></tr></table></figure>
</li>
<li><p>获取默认的子网掩码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func (ip IP) DefaultMask() IPMask</div></pre></td></tr></table></figure>
</li>
<li><p>根据域名查找Ip的代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">func ResolveIPAddr(net,addr string)(*IPAddr,error)</div><div class="line">func LookupHost(name string)(cname string,addres []string,err error)</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="HTTP编程"><a href="#HTTP编程" class="headerlink" title="HTTP编程"></a>HTTP编程</h1><p>go语言中提供了最简洁的HTTP客户端实现，<code>net/http</code>包涵盖了HTTP客户端和服务器的具体实现。</p>
<h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func (c *Client) Get(url string) (r *Response, err error)</div><div class="line">func (c *Client) Post(url string, bodyType string, body io.Reader) (r *Response, err</div><div class="line">error)</div><div class="line">func (c *Client) PostForm(url string, data url.Values) (r *Response, err error)</div><div class="line">func (c *Client) Head(url string) (r *Response, err error)</div><div class="line">func (c *Client) Do(req *Request) (resp *Response, err error)</div></pre></td></tr></table></figure>
<h3 id="http-Get"><a href="#http-Get" class="headerlink" title="http.Get()"></a>http.Get()</h3><p>示例代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import(</div><div class="line">	<span class="string">"net/http"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"io"</span></div><div class="line">)</div><div class="line"></div><div class="line">func checkError(err error)&#123;</div><div class="line">	<span class="keyword">if</span> err != nil&#123;</div><div class="line">		fmt.Fprint(os.Stderr,<span class="string">"Get a error:"</span>,err.Error())</div><div class="line">		os.Exit(1)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func <span class="function"><span class="title">main</span></span>()&#123;</div><div class="line">	urls := <span class="string">"http://www.baidu.com"</span></div><div class="line">	resp,err := http.Get(urls)</div><div class="line">	defer resp.Body.Close()</div><div class="line">	checkError(err)</div><div class="line">	fmt.Printf(<span class="string">"%T\n"</span>,resp)  // *http.Response</div><div class="line">	fmt.Println(resp) // &amp;&#123;200 OK 200 HTTP/1.1 1 1 map[Vary:[Accept-Encoding] Cache-Control:[private] Cxy_all:[baidu+b86eaf9909bfa485e740b338f43b59e4] X-Ua-Compatible:[IE=Edge,chrome=1] Bdqid:[0xe2ac35b70002667b] Date:[Mon, 01 Jan 2018 04:16:12 GMT] Server:[BWS/1.1] Bdpagetype:[1] Set-Cookie:[BAIDUID=DE298A334FAC18832841B94022D548FE:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com BIDUPSID=DE298A334FAC18832841B94022D548FE; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com PSTM=1514780172; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com BDSVRTM=0; path=/ BD_HOME=0; path=/ H_PS_PSSID=1444_21105_25178_20930; path=/; domain=.baidu.com] X-Powered-By:[HPHP] Content-Type:[text/html; charset=utf-8] Connection:[Keep-Alive] P3p:[CP=<span class="string">" OTI DSP COR IVA OUR IND COM "</span>] Expires:[Mon, 01 Jan 2018 04:15:27 GMT] Bduserid:[0]] 0xc042112060 -1 [chunked] <span class="literal">false</span> <span class="literal">true</span> map[] 0xc0420d6000 &lt;nil&gt;&#125;</div><div class="line">	//fmt.Printf(<span class="string">"%T\n"</span>,*resp)</div><div class="line">	fmt.Println(*resp) //&#123;200 OK 200 HTTP/1.1 1 1 map[X-Powered-By:[HPHP] Bdqid:[0xf86e314e000243bf] Bduserid:[0] Date:[Mon, 01 Jan 2018 04:16:45 GMT] Vary:[Accept-Encoding] P3p:[CP=<span class="string">" OTI DSP COR IVA OUR IND COM "</span>] Cxy_all:[baidu+d6f93791c456030fa1cbb6dc40c8a3d7] Content-Type:[text/html; charset=utf-8] Expires:[Mon, 01 Jan 2018 04:15:45 GMT] Bdpagetype:[1] Cache-Control:[private] X-Ua-Compatible:[IE=Edge,chrome=1] Connection:[Keep-Alive] Set-Cookie:[BAIDUID=6F1755A8470B4D4921661A215B6279D9:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com BIDUPSID=6F1755A8470B4D4921661A215B6279D9; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com PSTM=1514780205; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com BDSVRTM=0; path=/ BD_HOME=0; path=/ H_PS_PSSID=1424_21095_18560_25178_22158; path=/; domain=.baidu.com] Server:[BWS/1.1]] 0xc0420de0e0 -1 [chunked] <span class="literal">false</span> <span class="literal">true</span> map[] 0xc0420d6000 &lt;nil&gt;&#125;</div><div class="line">	fmt.Println(resp.Body) //&amp;&#123;0xc042050300 &lt;nil&gt; &lt;nil&gt;&#125; <span class="built_in">type</span> io.ReadCloser</div><div class="line">	io.Copy(os.Stdout,resp.Body) //获取Body部分,将body部分打印到标准输出流中，仅限io.Read*类型的</div><div class="line">	fmt.Println(resp.Header)  //返回map</div><div class="line">	fmt.Println(resp.Header[<span class="string">"Set-Cookie"</span>][0]) //BAIDUID=EE1F6D4895A059CB0FE00DBD9A413603:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com</div><div class="line">	fmt.Println(resp.StatusCode)  //200 状态码 int</div><div class="line">	fmt.Println(http.StatusOK) // 200</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="http-Post"><a href="#http-Post" class="headerlink" title="http.Post()"></a>http.Post()</h3><p>以POST方式发送数据，传递以下三个参数即可</p>
<ul>
<li>请求的目标URL</li>
<li>将要POST数据的资源类型(MIMEType)</li>
<li>数据的比特流([]byte形式)<br>下面一段代码是演示了如何上传了一张图片<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">resp,err := http.Post(<span class="string">"http://example.com"</span>,<span class="string">"image/jpeg"</span>,&amp;imageDatabuf)</div><div class="line"><span class="keyword">if</span> err!=nil&#123;</div><div class="line">  //处理错误</div><div class="line">  <span class="built_in">return</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> resp.StatusCode != http.StatuOK&#123;</div><div class="line">  //处理错误</div><div class="line">  <span class="built_in">return</span></div><div class="line">&#125;</div><div class="line">// ...</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="http-PostForm"><a href="#http-PostForm" class="headerlink" title="http.PostForm()"></a>http.PostForm()</h3><p>该方法实现编码格式为<code>application/x-www-from-urlencoded</code>的表单提交。<br>下面的示例代码模拟HTML表单提交一篇新文章<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import(</div><div class="line">	<span class="string">"net/http"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"net/url"</span></div><div class="line">)</div><div class="line"></div><div class="line">func checkError(err error)&#123;</div><div class="line">	<span class="keyword">if</span> err != nil&#123;</div><div class="line">		fmt.Fprint(os.Stderr,<span class="string">"Get a error:"</span>,err.Error())</div><div class="line">		os.Exit(1)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func <span class="function"><span class="title">main</span></span>()&#123;</div><div class="line"></div><div class="line">	urls := <span class="string">"http://www.dmmjy9.com/login"</span></div><div class="line">	//url.Values 它通常用于查询参数和表单值。与http.Header映射不同，值映射中的键区分大小写。</div><div class="line">	resp,err := http.PostForm(urls,url.Values&#123;<span class="string">"username"</span>:&#123;<span class="string">"dmmjy9"</span>&#125;,<span class="string">"password"</span>:&#123;<span class="string">"password"</span>&#125;&#125;)  //password=password&amp;username=dmmjy9,key值区分大小写</div><div class="line">	defer resp.Body.Close()</div><div class="line">	checkError(err)</div><div class="line"></div><div class="line">	fmt.Println(resp.StatusCode) //200</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="http-Head"><a href="#http-Head" class="headerlink" title="http.Head()"></a>http.Head()</h3><p>该请求方式表明只请求目标URL的头部信息，<strong>即HTTP Header而不返回HTTP body</strong>。跟<code>Get()</code>方法一样，只传入一个url就可以了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">       urls := <span class="string">"http://www.dmmjy9.com/login"</span></div><div class="line">resp,err = http.Head(urls)</div><div class="line">checkError(err)</div><div class="line">defer resp.Body.Close()</div><div class="line">fmt.Println(resp.Header)</div></pre></td></tr></table></figure></p>
<h3 id="http-Client-Do"><a href="#http-Client-Do" class="headerlink" title="(*http.Client).Do()"></a>(*http.Client).Do()</h3><p>在多数情况下，<code>http.Get()</code>和<code>http.PostForm()</code>就可以满足需求。，但是如果我们发起的http请求需要定制更多的信息，例如设定user-agent，传递cookie等<br>此时就可以使用<code>net/http</code>包中的<code>http.Client</code>对象的<code>Do()</code>方法来实现<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import(</div><div class="line">	<span class="string">"net/http"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">)</div><div class="line"></div><div class="line">func checkError(err error)&#123;</div><div class="line">	<span class="keyword">if</span> err != nil&#123;</div><div class="line">		fmt.Fprint(os.Stderr,<span class="string">"Get a error:"</span>,err.Error())</div><div class="line">		os.Exit(1)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func <span class="function"><span class="title">main</span></span>()&#123;</div><div class="line"></div><div class="line">	urls := <span class="string">"http://www.dmmjy9.com/login"</span></div><div class="line">	//自定义请求</div><div class="line">	req,err := http.NewRequest(<span class="string">"GET"</span>,urls,nil)</div><div class="line">	checkError(err)</div><div class="line">	//defer req.Body.Close() //空指针。抛异常</div><div class="line"></div><div class="line">	req.Header.Add(<span class="string">"user-agent"</span>,<span class="string">"python3.0"</span>)</div><div class="line">	//使用自定义请求包访问目标网站</div><div class="line">	client := http.Client&#123;&#125;</div><div class="line">	resp,err := client.Do(req)</div><div class="line">	checkError(err)</div><div class="line">	defer resp.Body.Close()</div><div class="line">	fmt.Println(resp.Header) //map[Date:[Mon, 01 Jan 2018 04:58:59 GMT] Content-Type:[text/html; charset=utf-8] Set-Cookie:[csrftoken=o3mfJHvfXegATpA38kTFcl6eKt2Nkgmr; expires=Mon, 31-Dec-2018 04:58:59 GMT; Max-Age=31449600; Path=/] Server:[nginx/1.10.3 (Ubuntu)] Vary:[Cookie] X-Frame-Options:[SAMEORIGIN] Connection:[keep-alive]]</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="高级封装"><a href="#高级封装" class="headerlink" title="高级封装"></a>高级封装</h2><p> 前面我们使用的<code>http.Get()</code>,’http.Post()’,’http.PostForm()’和<code>http.Hear()</code>方法都是在<code>http.DefaultClient()</code>基础上进行调用的，比如<code>http.Get()</code>等价于<code>http.DefaultClient.Get()</code>既然有默认的，那就说明也可以进行自定义，<br>下面是http.Client类型的结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">type Client struct &#123;</div><div class="line">	//Transport用于确定HTTP请求的创建机制，如果为空将会使用DefaultTransport</div><div class="line">	Transport RoundTripper</div><div class="line"></div><div class="line">	//CheckRedirect定义重定向策略，如果函数不为空，客户端将在跟踪HTTp重定向前调用该函数，</div><div class="line">       //两个参数req与via分别为即将发起的请求盒已经发起的所有请求，最早的发起的请求在最前面，如果该函数返回错误，客户端也将直接返回错误，不会再发起该请求，如果该函数为空，Client将采用一种默认的策略，将在10个连接请求后终止。</div><div class="line">	CheckRedirect func(req *Request, via []*Request) error</div><div class="line"></div><div class="line">	// 如果Jar为空，Cookie将不会再请求中发送，而且也会在响应在被忽略</div><div class="line">	Jar CookieJar</div><div class="line"></div><div class="line">	// Timeout specifies a time limit for requests made by this</div><div class="line">	// Client. The timeout includes connection time, any</div><div class="line">	// redirects, and reading the response body. The timer remains</div><div class="line">	// running after Get, Head, Post, or Do return and will</div><div class="line">	// interrupt reading of the Response.Body.</div><div class="line">	//</div><div class="line">	// A Timeout of zero means no timeout.  如果为0就没有超时时间</div><div class="line">	//</div><div class="line">	// The Client cancels requests to the underlying Transport</div><div class="line">	// using the Request.Cancel mechanism. Requests passed</div><div class="line">	// to Client.Do may still set Request.Cancel; both will</div><div class="line">	// cancel the request.</div><div class="line">	//</div><div class="line">	// For compatibility, the Client will also use the deprecated</div><div class="line">	// CancelRequest method on Transport if found. New</div><div class="line">	// RoundTripper implementations should use Request.Cancel</div><div class="line">	// instead of implementing CancelRequest.</div><div class="line">	Timeout time.Duration</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>Transport</code>类型必须实现http.RoundTripper接口，如果不指定具体的Transport，默认会使用http.DefaultTransport。<code>net/http</code>包中的http.Transport类型实现了http.RoundTripper接口</p>
<p>CheckRedirect函数指定处理重定向的策略。当使用HTTP Client的Get或者Head方法发送HTTP请求时，如果响应返回的状态码为30x，HTTP Client客户端将在跟踪HTTp重定向前调用该函数</p>
<p>Jar可用于在HTTP Client中设定Cookie，Jar的类型必须实现了http.CookieJar接口，该接口中预定义了SetCookies和Cookies两个方法。实际上我们一般用<code>http.SetCookies()</code>来设定Cookie<br>示例代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import(</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">)</div><div class="line"></div><div class="line">func checkError(err error)&#123;</div><div class="line">	<span class="keyword">if</span> err != nil&#123;</div><div class="line">		fmt.Printf(os.Stderr,<span class="string">"Get a error:%s"</span>,err.Error())</div><div class="line">		os.Exit(1)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func <span class="function"><span class="title">main</span></span>()&#123;</div><div class="line">	urls := <span class="string">"http://www.baidu.com"</span></div><div class="line">    // 修改重定向策略</div><div class="line">	client := http.Client&#123;</div><div class="line">		CheckRedirect: // redirectPolicyFunc</div><div class="line">	&#125;</div><div class="line">	resp,err:=client.Get(urls)</div><div class="line">	checkError(err)</div><div class="line">	defer resp.Body.Close()</div><div class="line">	fmt.Println(resp.Header)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="自定义http-Transport"><a href="#自定义http-Transport" class="headerlink" title="自定义http.Transport"></a>自定义http.Transport</h3><p>在http.Client类型的结构定义中我们看见的第一个数据成员就是一个http.Transport对象，该对象指定执行一个HTTP请求时的运行规则<br>http.Transport类型的具体结构<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">type</span> Transport struct &#123;</div><div class="line">	idleMu     sync.Mutex</div><div class="line">	wantIdle   bool                                // user has requested to close all idle conns 关闭所有闲置的连接</div><div class="line">	idleConn   map[connectMethodKey][]*persistConn // most recently used at end</div><div class="line">	idleConnCh map[connectMethodKey]chan *persistConn</div><div class="line">	idleLRU    connLRU</div><div class="line"></div><div class="line">	reqMu       sync.Mutex</div><div class="line">	reqCanceler map[*Request]func(error)</div><div class="line"></div><div class="line">	altMu    sync.Mutex   // guards changing altProto only</div><div class="line">	altProto atomic.Value // of nil or map[string]RoundTripper, key is URI scheme</div><div class="line"></div><div class="line">	// Proxy specifies a <span class="keyword">function</span> to <span class="built_in">return</span> a proxy <span class="keyword">for</span> a given</div><div class="line">	// Request. If the <span class="keyword">function</span> returns a non-nil error, the</div><div class="line">	// request is aborted with the provided error.</div><div class="line">	//</div><div class="line">	// The proxy <span class="built_in">type</span> is determined by the URL scheme. <span class="string">"http"</span></div><div class="line">	// and <span class="string">"socks5"</span> are supported. If the scheme is empty,</div><div class="line">	// <span class="string">"http"</span> is assumed.</div><div class="line">	//</div><div class="line">	// If Proxy is nil or returns a nil *URL, no proxy is used.</div><div class="line">        // Proxy指定用于针对特定请求返回代理函数，如果该函数返回一个非空的错误，请求将终止并返回该错误，如果Proxy为空或者返回一个空的URL指针，将不使用代理</div><div class="line">	Proxy func(*Request) (*url.URL, error)</div><div class="line"></div><div class="line">	// DialContext specifies the dial <span class="keyword">function</span> <span class="keyword">for</span> creating unencrypted TCP connections.</div><div class="line">	// If DialContext is nil (and the deprecated Dial below is also nil),</div><div class="line">	// <span class="keyword">then</span> the transport dials using package net.</div><div class="line">	DialContext func(ctx context.Context, network, addr string) (net.Conn, error)</div><div class="line"></div><div class="line">	// Dial specifies the dial <span class="keyword">function</span> <span class="keyword">for</span> creating unencrypted TCP connections.</div><div class="line">	//</div><div class="line">	// Deprecated: Use DialContext instead, <span class="built_in">which</span> allows the transport</div><div class="line">	// to cancel dials as soon as they are no longer needed.</div><div class="line">	// If both are <span class="built_in">set</span>, DialContext takes priority.</div><div class="line">      // Dial指定用于创建TCP连接的dail()函数，如果Dial为空，默认使用net.Dial()函数</div><div class="line">	Dial func(network, addr string) (net.Conn, error)</div><div class="line"></div><div class="line">	// DialTLS specifies an optional dial <span class="keyword">function</span> <span class="keyword">for</span> creating</div><div class="line">	// TLS connections <span class="keyword">for</span> non-proxied HTTPS requests.</div><div class="line">	//</div><div class="line">	// If DialTLS is nil, Dial and TLSClientConfig are used.</div><div class="line">	//</div><div class="line">	// If DialTLS is <span class="built_in">set</span>, the Dial hook is not used <span class="keyword">for</span> HTTPS</div><div class="line">	// requests and the TLSClientConfig and TLSHandshakeTimeout</div><div class="line">	// are ignored. The returned net.Conn is assumed to already be</div><div class="line">	// past the TLS handshake.</div><div class="line">  </div><div class="line">	DialTLS func(network, addr string) (net.Conn, error)</div><div class="line"></div><div class="line">	// TLSClientConfig specifies the TLS configuration to use with</div><div class="line">	// tls.Client.</div><div class="line">	// If nil, the default configuration is used.</div><div class="line">	// If non-nil, HTTP/2 support may not be enabled by default.\</div><div class="line">    //TLSClientConfig 指定用于tls.Client的TLS配置，如果为空就使用默认配置</div><div class="line">	TLSClientConfig *tls.Config</div><div class="line"></div><div class="line">	// TLSHandshakeTimeout specifies the maximum amount of time waiting to</div><div class="line">	// <span class="built_in">wait</span> <span class="keyword">for</span> a TLS handshake. Zero means no timeout.</div><div class="line">	TLSHandshakeTimeout time.Duration</div><div class="line"></div><div class="line">	// DisableKeepAlives, <span class="keyword">if</span> <span class="literal">true</span>, prevents re-use of TCP connections</div><div class="line">	// between different HTTP requests.</div><div class="line">        //是否取消长连接，默认为<span class="literal">false</span>，即启用长连接</div><div class="line">	DisableKeepAlives bool</div><div class="line"></div><div class="line">	// DisableCompression, <span class="keyword">if</span> <span class="literal">true</span>, prevents the Transport from</div><div class="line">	// requesting compression with an <span class="string">"Accept-Encoding: gzip"</span></div><div class="line">	// request header when the Request contains no existing</div><div class="line">	// Accept-Encoding value. If the Transport requests gzip on</div><div class="line">	// its own and gets a gzipped response, it<span class="string">'s transparently</span></div><div class="line"><span class="string">	// decoded in the Response.Body. However, if the user</span></div><div class="line"><span class="string">	// explicitly requested gzip it is not automatically</span></div><div class="line"><span class="string">	// uncompressed.</span></div><div class="line"><span class="string">        //是否取消压缩Gzip，默认值为false。即启用压缩</span></div><div class="line"><span class="string">	DisableCompression bool</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">	// MaxIdleConns controls the maximum number of idle (keep-alive)</span></div><div class="line"><span class="string">	// connections across all hosts. Zero means no limit.</span></div><div class="line"><span class="string">   </span></div><div class="line"><span class="string">	MaxIdleConns int</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">	// MaxIdleConnsPerHost, if non-zero, controls the maximum idle</span></div><div class="line"><span class="string">	// (keep-alive) connections to keep per-host. If zero,</span></div><div class="line"><span class="string">	// DefaultMaxIdleConnsPerHost is used.</span></div><div class="line"><span class="string">        //如果MaxIdleConnsPerHost 为非零值，它用于控制每个host所需要保持的最大空闲连接谁，如果该值为空,则使用DefaultMaxIdleConnsPerHost </span></div><div class="line"><span class="string">	MaxIdleConnsPerHost int</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">	// IdleConnTimeout is the maximum amount of time an idle</span></div><div class="line"><span class="string">	// (keep-alive) connection will remain idle before closing</span></div><div class="line"><span class="string">	// itself.</span></div><div class="line"><span class="string">	// Zero means no limit.</span></div><div class="line"><span class="string">	IdleConnTimeout time.Duration</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">	// ResponseHeaderTimeout, if non-zero, specifies the amount of</span></div><div class="line"><span class="string">	// time to wait for a server'</span>s response headers after fully</div><div class="line">	// writing the request (including its body, <span class="keyword">if</span> any). This</div><div class="line">	// time does not include the time to <span class="built_in">read</span> the response body.</div><div class="line">	ResponseHeaderTimeout time.Duration</div><div class="line"></div><div class="line">	// ExpectContinueTimeout, <span class="keyword">if</span> non-zero, specifies the amount of</div><div class="line">	// time to <span class="built_in">wait</span> <span class="keyword">for</span> a server<span class="string">'s first response headers after fully</span></div><div class="line"><span class="string">	// writing the request headers if the request has an</span></div><div class="line"><span class="string">	// "Expect: 100-continue" header. Zero means no timeout and</span></div><div class="line"><span class="string">	// causes the body to be sent immediately, without</span></div><div class="line"><span class="string">	// waiting for the server to approve.</span></div><div class="line"><span class="string">	// This time does not include the time to send the request header.</span></div><div class="line"><span class="string">	ExpectContinueTimeout time.Duration</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">	// TLSNextProto specifies how the Transport switches to an</span></div><div class="line"><span class="string">	// alternate protocol (such as HTTP/2) after a TLS NPN/ALPN</span></div><div class="line"><span class="string">	// protocol negotiation. If Transport dials an TLS connection</span></div><div class="line"><span class="string">	// with a non-empty protocol name and TLSNextProto contains a</span></div><div class="line"><span class="string">	// map entry for that key (such as "h2"), then the func is</span></div><div class="line"><span class="string">	// called with the request'</span>s authority (such as <span class="string">"example.com"</span></div><div class="line">	// or <span class="string">"example.com:1234"</span>) and the TLS connection. The <span class="keyword">function</span></div><div class="line">	// must <span class="built_in">return</span> a RoundTripper that <span class="keyword">then</span> handles the request.</div><div class="line">	// If TLSNextProto is not nil, HTTP/2 support is not enabled</div><div class="line">	// automatically.</div><div class="line">	TLSNextProto map[string]func(authority string, c *tls.Conn) RoundTripper</div><div class="line"></div><div class="line">	// ProxyConnectHeader optionally specifies headers to send to</div><div class="line">	// proxies during CONNECT requests.</div><div class="line">	ProxyConnectHeader Header</div><div class="line"></div><div class="line">	// MaxResponseHeaderBytes specifies a <span class="built_in">limit</span> on how many</div><div class="line">	// response bytes are allowed <span class="keyword">in</span> the server<span class="string">'s response</span></div><div class="line"><span class="string">	// header.</span></div><div class="line"><span class="string">	//</span></div><div class="line"><span class="string">	// Zero means to use a default limit.</span></div><div class="line"><span class="string">	MaxResponseHeaderBytes int64</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">	// nextProtoOnce guards initialization of TLSNextProto and</span></div><div class="line"><span class="string">	// h2transport (via onceSetNextProtoDefaults)</span></div><div class="line"><span class="string">	nextProtoOnce sync.Once</span></div><div class="line"><span class="string">	h2transport   *http2Transport // non-nil if http2 wired up</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">	// TODO: tunable on max per-host TCP dials in flight (Issue 13957)</span></div><div class="line"><span class="string">&#125;</span></div></pre></td></tr></table></figure></p>
<p>除了公开数据成员外，还有几个公开的成员方法<br><code>func (t *Transport) CloseIdleConnections()</code>用于关闭所有非活跃的连接<br><code>func (t *Transport) RegisterProtocol(schema string, rt RoundTripper)</code>该方法用于注册并启用一个新的传输协议。比如webSocket或者FTP等<br><code>func (t *Transport) RoundTrip(req *Request)(resp *Response, err error)</code>用于实现http.RoundTripper接口<br>自定义的http.TransPort也简单<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//线程安全</div><div class="line">	tr := http.Transport&#123;</div><div class="line">		TLSClientConfig:tls.Config&#123;RootCAs:pool&#125;,</div><div class="line">		DisableCompression:<span class="literal">true</span></div><div class="line">	&#125;</div><div class="line">	client := http.Client&#123;</div><div class="line">		Transport:tr,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	resp,err:=client.Get(<span class="string">"http://www.baidu.com"</span>)</div></pre></td></tr></table></figure></p>
<h3 id="http-RoundTripper接口"><a href="#http-RoundTripper接口" class="headerlink" title="http.RoundTripper接口"></a>http.RoundTripper接口</h3><p>在http.Client定义的<strong>第一个公开成员就是http.Transport类型的实例，且该成员所对应的类型必须实现http.RoundTripper接口</strong><br>http.RoundTripper的定义<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">type</span> RoundTripper interface &#123;</div><div class="line">	// RoundTrip executes a single HTTP transaction, returning</div><div class="line">	// a Response <span class="keyword">for</span> the provided Request.</div><div class="line">	//</div><div class="line">	// RoundTrip should not attempt to interpret the response. In</div><div class="line">	// particular, RoundTrip must <span class="built_in">return</span> err == nil <span class="keyword">if</span> it obtained</div><div class="line">	// a response, regardless of the response<span class="string">'s HTTP status code.</span></div><div class="line"><span class="string">	// A non-nil err should be reserved for failure to obtain a</span></div><div class="line"><span class="string">	// response. Similarly, RoundTrip should not attempt to</span></div><div class="line"><span class="string">	// handle higher-level protocol details such as redirects,</span></div><div class="line"><span class="string">	// authentication, or cookies.</span></div><div class="line"><span class="string">	//</span></div><div class="line"><span class="string">	// RoundTrip should not modify the request, except for</span></div><div class="line"><span class="string">	// consuming and closing the Request'</span>s Body.</div><div class="line">	//</div><div class="line">	// RoundTrip must always close the body, including on errors,</div><div class="line">	// but depending on the implementation may <span class="keyword">do</span> so <span class="keyword">in</span> a separate</div><div class="line">	// goroutine even after RoundTrip returns. This means that</div><div class="line">	// callers wanting to reuse the body <span class="keyword">for</span> subsequent requests</div><div class="line">	// must arrange to <span class="built_in">wait</span> <span class="keyword">for</span> the Close call before doing so.</div><div class="line">	//</div><div class="line">	// The Request<span class="string">'s URL and Header fields must be initialized.</span></div><div class="line"><span class="string">//RoundTrip执行一个单一的HTTp事务，返回相应的响应信息，RoundTrip函数的实现不应试图去理解响应内容，如果RoundTrip得到一个响应，</span></div><div class="line"><span class="string">//无论该响应的HTTP状态码如何，都应将返回的err设置为nil，非空的err只意味着没有成功获取到响应。类似的，RoundTrip也不应该试图处理更高级别的协议，比如重定向、认证和Cookie等。</span></div><div class="line"><span class="string">//RoundTrip不应修改请求内容，除非是为了理解Body内容，每一个请求的URL和Header域都应被正确初始化</span></div><div class="line"><span class="string">	RoundTrip(*Request) (*Response, error)</span></div><div class="line"><span class="string">&#125;</span></div></pre></td></tr></table></figure></p>
<p><code>http.RoundTripper</code>接口很简单，只定义了一个名为RoundTrip的方法。任何实现了RoundTrip()方法的类型即可实现http.RoundTripper接口。<br>非必要情况下，不应该在RoundTrip()中改写传入的请求体(<em>Request)，请求体的内容必须在传入RoundTrip()之前就已经组织好并完成了初始化。<br>通常情况下，我们可以在<strong>默认的httpp.Transport之上包一层Transport并实现RoundTrip()方法。</strong><br><em>*示例代码</em></em><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import(</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="built_in">type</span> OurCustomTransport struct&#123;</div><div class="line">	Tranport http.Transport</div><div class="line">&#125;</div><div class="line"></div><div class="line">//用以判断是否使用自定义的transport</div><div class="line">func (t *OurCustomTransport) transport() http.RoundTripper&#123;</div><div class="line">	<span class="keyword">if</span> t.Tranport != nil&#123;</div><div class="line">		<span class="built_in">return</span> t.Tranport</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">return</span> http.DefaultTransport</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (t *OurCustomTransport) RoundTrip(req *http.Request) (*http.Response,error)&#123;</div><div class="line">	//处理事情</div><div class="line">	//发起HTTP请求</div><div class="line">	</div><div class="line">	<span class="built_in">return</span> t.tranport().RoundTrip(req)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (t *OurCustomTransport) Client() *http.Client&#123;</div><div class="line">	<span class="built_in">return</span> http.Client&#123;Transport:t&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func <span class="function"><span class="title">main</span></span>()&#123;</div><div class="line">	t := OurCustomTransport&#123;</div><div class="line">		// ...</div><div class="line">	&#125; </div><div class="line">	c := t.Client()</div><div class="line">	resp.err := c.Get(<span class="string">"http://www.baidu.com"</span>)</div><div class="line">	// ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="HTTP服务端"><a href="#HTTP服务端" class="headerlink" title="HTTP服务端"></a>HTTP服务端</h1><p>使用net/http包提供的http.ListenAndServe()方法，可以在指定的地址进行监听。开启一个http。每次客户端有请求的时候，把请求封装成 http.Request，调用对应的 handler 的 ServeHTTP 方法，然后把操作后的 http.ResponseWriter 解析，返回到客户端。<br><code>func ListenAndServe(addr string, handler Handler) error</code><br>该方法用于在指定的TCP网络地址addr处进行监听，然后调用服务端程序来处理传入的连接请求，该方法有两个参数。addr为监听的地址，第二参数表示服务端处理程序，通常为空，这意味着服务端调用<code>http.DefaultServeMux</code>进行处理，而服务端编写的业务逻辑处理程序http.Handler()或http.HandleFunc()默认注入http.DefaultServeMux中。<br>代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import(</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">	<span class="string">"html"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">)</div><div class="line"></div><div class="line">func <span class="function"><span class="title">main</span></span>()&#123;</div><div class="line">	//http.Handle(<span class="string">"\foo"</span>,fooHander)</div><div class="line">	http.HandleFunc(<span class="string">"/"</span>,func(w http.ResponseWriter,r *http.Request)&#123;</div><div class="line">		fmt.Fprintf(w,<span class="string">"Hello %q"</span>,html.EscapeString(r.URL.Path)) //将数据流从w输出，w为ResponseWriter</div><div class="line">	&#125;)</div><div class="line">	log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>,nil))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>访问127.0.0.1：8080即可获得Hello “/“<br>我们只要写一个 handler，请求会通过参数传递进来，而它要做的就是根据请求的数据做处理，把结果写到 Response 中.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import(</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">	//<span class="string">"html"</span></div><div class="line">	//<span class="string">"log"</span></div><div class="line">)</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">type</span> helloHandler struct&#123;&#125;</div><div class="line"></div><div class="line">//</div><div class="line">func (h *helloHandler) ServeHTTP(w http.ResponseWriter,r *http.Request)&#123;</div><div class="line">	fmt.Fprintf(w,<span class="string">"hello world!!"</span>)</div><div class="line">&#125;</div><div class="line">func <span class="function"><span class="title">main</span></span>()&#123;</div><div class="line">	http.Handle(<span class="string">"/"</span>,&amp;helloHandler&#123;&#125;)  //传入的是指针</div><div class="line">	http.ListenAndServe(<span class="string">":12345"</span>,nil)  //监听的是12345端口</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正如上面程序展示的那样，我们只要实现的一个 Handler，它的<a href="https://golang.org/pkg/net/http/#Handler" target="_blank" rel="external">接口原型</a>是（也就是说<strong>只要实现了 <code>ServeHTTP</code> 方法的对象都可以作为 Handler</strong>）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">type</span> Handler interface &#123;</div><div class="line">    ServeHTTP(ResponseWriter, *Request)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后，注册到对应的路由路径上就 OK 了。<br><code>http.HandleFunc</code>接受两个参数：第一个参数是字符串表示的 url 路径，第二个参数是该 url 实际的处理对象。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>每次写handler时，我们都要的一个类型，然后在编写对应的ServeHTTP方法，这算是重复的工作，因此我们可以将这些重复的工作抽象出来，<code>net/http</code>提供了<code>http.HandleFunc</code>方法。<br>修改上面的代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import(</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">	//<span class="string">"html"</span></div><div class="line">	<span class="string">"io"</span></div><div class="line">)</div><div class="line"></div><div class="line">func hellHandler2(w http.ResponseWriter,r *http.Request)&#123;</div><div class="line">	//fmt.Fprintf(w,<span class="string">"Hello World!!!"</span>)</div><div class="line">	io.WriteString(w,<span class="string">"Hello World"</span>)</div><div class="line">&#125;</div><div class="line">func <span class="function"><span class="title">main</span></span>()&#123;</div><div class="line">	http.HandleFunc(<span class="string">"/"</span>,hellHandler2)</div><div class="line">	http.ListenAndServe(<span class="string">":12345"</span>,nil)  //监听的是12345端口</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实，HandleFunc 只是一个适配器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">type</span> HandlerFunc func(ResponseWriter, *Request)</div><div class="line"></div><div class="line">// ServeHTTP calls f(w, r).</div><div class="line">func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) &#123;</div><div class="line">	f(w, r)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>自动给 f 函数添加了 HandlerFunc 这个壳，最终调用的还是 ServerHTTP，只不过会直接使用 f(w, r).有点类似于装饰器。</p>
<h2 id="常用的Handler"><a href="#常用的Handler" class="headerlink" title="常用的Handler"></a>常用的Handler</h2><p>net/http提供了比较常用的处理器。比如负责文件 hosting 的<code>FileServer</code>、负责 404 的<code>NotFoundHandler</code> 和 负责重定向的<code>RedirectHandler</code><br>将当前目录所有文件host到服务端<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import <span class="string">"net/http"</span></div><div class="line"></div><div class="line">func <span class="function"><span class="title">main</span></span>()&#123;</div><div class="line">	http.ListenAndServe(<span class="string">":12345"</span>,http.FileServer(http.Dir(<span class="string">"."</span>)))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果<img src="http://upload-images.jianshu.io/upload_images/6853514-9ea8b1984dbac948.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>在实际开发过程中，HTTP接口会有许多的URL和对应的Handler。在Go语言中有一个重要的概念<code>ServeMux</code>。<code>Mux</code>是multiplexor的缩写，就是多路传输的意思（请求传过来，根据某种方式判断，分流到后端多个不同的地方）。<code>ServeMux</code>可以注册多个URL和handler的对应关系，并主动把请求转发到对应的handler进行处理。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import(</div><div class="line">	<span class="string">"net/http"</span></div><div class="line">	<span class="string">"io"</span></div><div class="line">)</div><div class="line"></div><div class="line">func helloHandler(w http.ResponseWriter,r *http.Request)&#123;</div><div class="line">	io.WriteString(w,<span class="string">"Hello World!!!\n"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">func echoHandler(w http.ResponseWriter,r *http.Request)&#123;</div><div class="line">	io.WriteString(w,r.URL.Path)  //从http.Request提取路径 这里为<span class="string">"/"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">func <span class="function"><span class="title">main</span></span>()&#123;</div><div class="line">	mux := http.NewServeMux()</div><div class="line">	mux.HandleFunc(<span class="string">"/"</span>,echoHandler)  // 返回/</div><div class="line">	mux.HandleFunc(<span class="string">"/hello"</span>,helloHandler) //返回 Hello World</div><div class="line">	http.ListenAndServe(<span class="string">":12345"</span>,mux)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>请求的url是/hello 就返回hello world！！！；否则就返回URL的路径，路径是从古请求对象<code>http.Request</code>中提取的。</p>
<p>这段代码通过<code>NewServeMux</code>生成了<code>ServeMux</code>结构，URL和handler是通过他注册的，<code>http.ListenAndServe</code>方法的第二个参数变成了上面的mux变量。<br>通过查看源代码我们知道<code>http.ListenAndServe</code>的第二工参数是handler类型的变量。因此可以推断出<code>ServeMux</code>是Handler接口的实现，源代码如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">type</span> ServeMux struct &#123;</div><div class="line">        // contains filtered or unexported fields</div><div class="line">&#125;</div><div class="line"></div><div class="line">func NewServeMux() *ServeMux</div><div class="line">func (mux *ServeMux) Handle(pattern string, handler Handler)</div><div class="line">func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))</div><div class="line">func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)</div><div class="line">func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)</div></pre></td></tr></table></figure></p>
<p>除了<code>Handler()</code>返回某个请求的 <code>Handler</code>。Handle和HandleFunc 这两个方法 net/http 也提供了。而 ServeHTTP 就是 ServeMux 的核心处理逻辑：根据传递过来的 Request，匹配之前注册的 URL 和处理函数，找到最匹配的项，进行处理。可以说 ServeMux 是个特殊的 Handler，它负责路由和调用其他后端Handler 的处理方法。</p>
<h2 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h2><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>首先分析<code>http.ListenAndServe</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">func ListenAndServe(addr string, handler Handler) error &#123;</div><div class="line">	server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</div><div class="line">	<span class="built_in">return</span> server.ListenAndServe()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数其实也是一层封装，创建了<code>Server</code>结构，并调用他的<code>ListenAndServe</code>方法，继续深入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// A Server defines parameters <span class="keyword">for</span> running an HTTP server.</div><div class="line">// The zero value <span class="keyword">for</span> Server is a valid configuration.</div><div class="line"><span class="built_in">type</span> Server struct &#123;</div><div class="line">	Addr      string      // TCP address to listen on, <span class="string">":http"</span> <span class="keyword">if</span> empty</div><div class="line">	Handler   Handler     // handler to invoke, http.DefaultServeMux <span class="keyword">if</span> nil</div><div class="line">	TLSConfig *tls.Config // optional TLS config, used by ServeTLS and ListenAndServeTLS</div><div class="line"></div><div class="line">	// ReadTimeout is the maximum duration <span class="keyword">for</span> reading the entire</div><div class="line">	// request, including the body.</div><div class="line">	//</div><div class="line">	// Because ReadTimeout does not <span class="built_in">let</span> Handlers make per-request</div><div class="line">	// decisions on each request body<span class="string">'s acceptable deadline or</span></div><div class="line"><span class="string">	// upload rate, most users will prefer to use</span></div><div class="line"><span class="string">	// ReadHeaderTimeout. It is valid to use them both.</span></div><div class="line"><span class="string">	ReadTimeout time.Duration</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">// ListenAndServe listens on the TCP network address srv.Addr and then</span></div><div class="line"><span class="string">// calls Serve to handle requests on incoming connections.  If</span></div><div class="line"><span class="string">// srv.Addr is blank, ":http" is used.</span></div><div class="line"><span class="string">func (srv *Server) ListenAndServe() error &#123;</span></div><div class="line"><span class="string">	addr := srv.Addr</span></div><div class="line"><span class="string">	if addr == "" &#123;</span></div><div class="line"><span class="string">		addr = ":http"</span></div><div class="line"><span class="string">	&#125;</span></div><div class="line"><span class="string">	ln, err := net.Listen("tcp", addr) //调用net.Listen监听在对应的tcp端口</span></div><div class="line"><span class="string">	if err != nil &#123;</span></div><div class="line"><span class="string">		return err</span></div><div class="line"><span class="string">	&#125;</span></div><div class="line"><span class="string">	return srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;) //tcpKeepAliveListener设置了tcp的KeeppAlive功能。最后调用srv.Serve()方法开始真正的循环逻辑</span></div><div class="line"><span class="string">&#125;</span></div></pre></td></tr></table></figure></p>
<p>Server保存了运行HTTP服务需要的参数，跟入Serve方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">// Serve accepts incoming connections on the Listener l, creating a</div><div class="line">// new service goroutine <span class="keyword">for</span> each. The service goroutines <span class="built_in">read</span> requests and</div><div class="line">// <span class="keyword">then</span> call srv.Handler to reply to them.</div><div class="line">//</div><div class="line">// For HTTP/2 support, srv.TLSConfig should be initialized to the</div><div class="line">// provided listener<span class="string">'s TLS Config before calling Serve. If</span></div><div class="line"><span class="string">// srv.TLSConfig is non-nil and doesn'</span>t include the string <span class="string">"h2"</span> <span class="keyword">in</span></div><div class="line">// Config.NextProtos, HTTP/2 support is not enabled.</div><div class="line">//</div><div class="line">// Serve always returns a non-nil error. After Shutdown or Close, the</div><div class="line">// returned error is ErrServerClosed.</div><div class="line">//主要功能：接受Listener l传递过来的请求，为每个请求创建goroutine进行后台处理，goroutine会读取请求，调用srv.Handler</div><div class="line">func (srv *Server) Serve(l net.Listener) error &#123;</div><div class="line">	defer l.Close()</div><div class="line">	<span class="keyword">if</span> fn := testHookServerServe; fn != nil &#123;</div><div class="line">		fn(srv, l)</div><div class="line">	&#125;</div><div class="line">	var tempDelay time.Duration // how long to sleep on accept failure</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err := srv.setupHTTP2_Serve(); err != nil &#123;</div><div class="line">		<span class="built_in">return</span> err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	srv.trackListener(l, <span class="literal">true</span>)</div><div class="line">	defer srv.trackListener(l, <span class="literal">false</span>)</div><div class="line"></div><div class="line">	baseCtx := context.Background() // base is always background, per Issue 16220</div><div class="line">	ctx := context.WithValue(baseCtx, ServerContextKey, srv)</div><div class="line">    //循环逻辑，接受并处理请求</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">                //有新的连接</div><div class="line">		rw, e := l.Accept()</div><div class="line">		<span class="keyword">if</span> e != nil &#123;</div><div class="line">			select &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-srv.getDoneChan():</div><div class="line">				<span class="built_in">return</span> ErrServerClosed</div><div class="line">			default:</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.<span class="function"><span class="title">Temporary</span></span>() &#123;</div><div class="line">				<span class="keyword">if</span> tempDelay == 0 &#123;</div><div class="line">					tempDelay = 5 * time.Millisecond</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					tempDelay *= 2</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> max := 1 * time.Second; tempDelay &gt; max &#123;</div><div class="line">					tempDelay = max</div><div class="line">				&#125;</div><div class="line">				srv.logf(<span class="string">"http: Accept error: %v; retrying in %v"</span>, e, tempDelay)</div><div class="line">				time.Sleep(tempDelay)</div><div class="line">				<span class="built_in">continue</span></div><div class="line">			&#125;</div><div class="line">			<span class="built_in">return</span> e</div><div class="line">		&#125;</div><div class="line">		tempDelay = 0</div><div class="line">              //创建Conn连接</div><div class="line">		c := srv.newConn(rw)</div><div class="line">		c.setState(c.rwc, StateNew) // before Serve can <span class="built_in">return</span></div><div class="line">                //启动新的goroutine进行处理</div><div class="line">		go c.serve(ctx)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>再跟入</strong><code>c.serve()</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line">// Serve a new connection. 提供一个新的连接</div><div class="line">func (c *conn) serve(ctx context.Context) &#123;</div><div class="line">	c.remoteAddr = c.rwc.RemoteAddr().String()</div><div class="line">	ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())</div><div class="line">	defer <span class="function"><span class="title">func</span></span>() &#123;</div><div class="line">		<span class="keyword">if</span> err := recover(); err != nil &amp;&amp; err != ErrAbortHandler &#123;</div><div class="line">			const size = 64 &lt;&lt; 10</div><div class="line">			buf := make([]byte, size)</div><div class="line">			buf = buf[:runtime.Stack(buf, <span class="literal">false</span>)]</div><div class="line">			c.server.logf(<span class="string">"http: panic serving %v: %v\n%s"</span>, c.remoteAddr, err, buf)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> !c.<span class="function"><span class="title">hijacked</span></span>() &#123;</div><div class="line">			c.close()</div><div class="line">			c.setState(c.rwc, StateClosed)</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> tlsConn, ok := c.rwc.(*tls.Conn); ok &#123;</div><div class="line">		<span class="keyword">if</span> d := c.server.ReadTimeout; d != 0 &#123;</div><div class="line">			c.rwc.SetReadDeadline(time.Now().Add(d))</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> d := c.server.WriteTimeout; d != 0 &#123;</div><div class="line">			c.rwc.SetWriteDeadline(time.Now().Add(d))</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> err := tlsConn.Handshake(); err != nil &#123;</div><div class="line">			c.server.logf(<span class="string">"http: TLS handshake error from %s: %v"</span>, c.rwc.RemoteAddr(), err)</div><div class="line">			<span class="built_in">return</span></div><div class="line">		&#125;</div><div class="line">		c.tlsState = new(tls.ConnectionState)</div><div class="line">		*c.tlsState = tlsConn.ConnectionState()</div><div class="line">		<span class="keyword">if</span> proto := c.tlsState.NegotiatedProtocol; validNPN(proto) &#123;</div><div class="line">			<span class="keyword">if</span> fn := c.server.TLSNextProto[proto]; fn != nil &#123;</div><div class="line">				h := initNPNRequest&#123;tlsConn, serverHandler&#123;c.server&#125;&#125;</div><div class="line">				fn(c.server, tlsConn, h)</div><div class="line">			&#125;</div><div class="line">			<span class="built_in">return</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// HTTP/1.x from here on.</div><div class="line"></div><div class="line">	ctx, cancelCtx := context.WithCancel(ctx)</div><div class="line">	c.cancelCtx = cancelCtx</div><div class="line">	defer cancelCtx()</div><div class="line"></div><div class="line">	c.r = &amp;connReader&#123;conn: c&#125;</div><div class="line">	c.bufr = newBufioReader(c.r)</div><div class="line">	c.bufw = newBufioWriterSize(checkConnErrorWriter&#123;c&#125;, 4&lt;&lt;10)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		w, err := c.readRequest(ctx)</div><div class="line">		<span class="keyword">if</span> c.r.remain != c.server.<span class="function"><span class="title">initialReadLimitSize</span></span>() &#123;</div><div class="line">			// If we <span class="built_in">read</span> any bytes off the wire, we<span class="string">'re active.</span></div><div class="line"><span class="string">			c.setState(c.rwc, StateActive)</span></div><div class="line"><span class="string">		&#125;</span></div><div class="line"><span class="string">		if err != nil &#123;</span></div><div class="line"><span class="string">			const errorHeaders = "\r\nContent-Type: text/plain; charset=utf-8\r\nConnection: close\r\n\r\n"</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">			if err == errTooLarge &#123;</span></div><div class="line"><span class="string">				// Their HTTP client may or may not be</span></div><div class="line"><span class="string">				// able to read this if we'</span>re</div><div class="line">				// responding to them and hanging up</div><div class="line">				// <span class="keyword">while</span> they<span class="string">'re still writing their</span></div><div class="line"><span class="string">				// request. Undefined behavior.</span></div><div class="line"><span class="string">				const publicErr = "431 Request Header Fields Too Large"</span></div><div class="line"><span class="string">				fmt.Fprintf(c.rwc, "HTTP/1.1 "+publicErr+errorHeaders+publicErr)</span></div><div class="line"><span class="string">				c.closeWriteAndWait()</span></div><div class="line"><span class="string">				return</span></div><div class="line"><span class="string">			&#125;</span></div><div class="line"><span class="string">			if isCommonNetReadError(err) &#123;</span></div><div class="line"><span class="string">				return // don'</span>t reply</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			publicErr := <span class="string">"400 Bad Request"</span></div><div class="line">			<span class="keyword">if</span> v, ok := err.(badRequestError); ok &#123;</div><div class="line">				publicErr = publicErr + <span class="string">": "</span> + string(v)</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			fmt.Fprintf(c.rwc, <span class="string">"HTTP/1.1 "</span>+publicErr+errorHeaders+publicErr)</div><div class="line">			<span class="built_in">return</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// Expect 100 Continue support</div><div class="line">		req := w.req</div><div class="line">		<span class="keyword">if</span> req.<span class="function"><span class="title">expectsContinue</span></span>() &#123;</div><div class="line">			<span class="keyword">if</span> req.ProtoAtLeast(1, 1) &amp;&amp; req.ContentLength != 0 &#123;</div><div class="line">				// Wrap the Body reader with one that replies on the connection</div><div class="line">				req.Body = &amp;expectContinueReader&#123;readCloser: req.Body, resp: w&#125;</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> req.Header.get(<span class="string">"Expect"</span>) != <span class="string">""</span> &#123;</div><div class="line">			w.sendExpectationFailed()</div><div class="line">			<span class="built_in">return</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		c.curReq.Store(w)</div><div class="line"></div><div class="line">		<span class="keyword">if</span> requestBodyRemains(req.Body) &#123;</div><div class="line">			registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">if</span> w.conn.bufr.Buffered() &gt; 0 &#123;</div><div class="line">				w.conn.r.closeNotifyFromPipelinedRequest()</div><div class="line">			&#125;</div><div class="line">			w.conn.r.startBackgroundRead()</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// HTTP cannot have multiple simultaneous active requests.[*]</div><div class="line">		// Until the server replies to this request, it can<span class="string">'t read another,</span></div><div class="line"><span class="string">		// so we might as well run the handler in this goroutine.</span></div><div class="line"><span class="string">		// [*] Not strictly true: HTTP pipelining. We could let them all process</span></div><div class="line"><span class="string">	 	// in parallel even if their responses need to be serialized.</span></div><div class="line"><span class="string">		// But we'</span>re not going to implement HTTP pipelining because it </div><div class="line">		// was never deployed <span class="keyword">in</span> the wild and the answer is HTTP/2.</div><div class="line">//下面这个serverHandler是最早传递给Server的Handler函数:		serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</div><div class="line">		w.cancelCtx()</div><div class="line">		<span class="keyword">if</span> c.<span class="function"><span class="title">hijacked</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span></div><div class="line">		&#125;</div><div class="line">		w.finishRequest()</div><div class="line">		<span class="keyword">if</span> !w.<span class="function"><span class="title">shouldReuseConnection</span></span>() &#123;</div><div class="line">			<span class="keyword">if</span> w.requestBodyLimitHit || w.<span class="function"><span class="title">closedRequestBodyEarly</span></span>() &#123;</div><div class="line">				c.closeWriteAndWait()</div><div class="line">			&#125;</div><div class="line">			<span class="built_in">return</span></div><div class="line">		&#125;</div><div class="line">		c.setState(c.rwc, StateIdle)</div><div class="line">		c.curReq.Store((*response)(nil))</div><div class="line"></div><div class="line">		<span class="keyword">if</span> !w.conn.server.<span class="function"><span class="title">doKeepAlives</span></span>() &#123;</div><div class="line">			// We<span class="string">'re in shutdown mode. We might'</span>ve replied</div><div class="line">			// to the user without <span class="string">"Connection: close"</span> and</div><div class="line">			// they might think they can send another</div><div class="line">			// request, but such is life with HTTP/1.1.</div><div class="line">			<span class="built_in">return</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> d := c.server.idleTimeout(); d != 0 &#123;</div><div class="line">			c.rwc.SetReadDeadline(time.Now().Add(d))</div><div class="line">			<span class="keyword">if</span> _, err := c.bufr.Peek(4); err != nil &#123;</div><div class="line">				<span class="built_in">return</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		c.rwc.SetReadDeadline(time.Time&#123;&#125;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>继续跟入<code>serverHandler{c.server}.ServeHTTP(w, w.req)</code>中的ServeHTTP<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) &#123;</div><div class="line">	handler := sh.srv.Handler</div><div class="line">	<span class="keyword">if</span> handler == nil &#123;</div><div class="line">		handler = DefaultServeMux //发现DefaultServeMux,如果没有handler，就会默认使用它</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</div><div class="line">		handler = globalOptionsHandler&#123;&#125;</div><div class="line">	&#125;</div><div class="line">//Handler 接口都要实现 ServeHTTP 这个方法，因为这里就要被调用啦。</div><div class="line">	handler.ServeHTTP(rw, req)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也就是说，无论如何，最终都会用到 ServeMux，也就是负责 URL 路由的家伙。前面也已经说过，它的 ServeHTTP 方法就是根据请求的路径，把它转交给注册的 handler 进行处理。</p>
<h3 id="ServeMux"><a href="#ServeMux" class="headerlink" title="ServeMux"></a>ServeMux</h3><p><code>ServeMux</code> 会以某种方式保存 URL 和 Handlers 的对应关系<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">type</span> ServeMux struct &#123;</div><div class="line">	mu    sync.RWMutex </div><div class="line">	m     map[string]muxEntry //// 存放路由信息的字典！</div><div class="line">	hosts bool // whether any patterns contain hostnames</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">type</span> muxEntry struct &#123;</div><div class="line">	explicit bool</div><div class="line">	h        Handler</div><div class="line">	pattern  string</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>路由信息保存在字典中，接下来就看看几个重要的操作：路由信息是怎么注册的？ServeHTTP 方法到底是怎么做的？路由查找过程是怎样的？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">// Handle registers the handler <span class="keyword">for</span> the given pattern.</div><div class="line">// If a handler already exists <span class="keyword">for</span> pattern, Handle panics.</div><div class="line">func (mux *ServeMux) Handle(pattern string, handler Handler) &#123;</div><div class="line">	mux.mu.Lock()</div><div class="line">	defer mux.mu.Unlock()</div><div class="line">        //边界情况处理</div><div class="line">	<span class="keyword">if</span> pattern == <span class="string">""</span> &#123;</div><div class="line">		panic(<span class="string">"http: invalid pattern "</span> + pattern)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> handler == nil &#123;</div><div class="line">		panic(<span class="string">"http: nil handler"</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> mux.m[pattern].explicit &#123;</div><div class="line">		panic(<span class="string">"http: multiple registrations for "</span> + pattern)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> mux.m == nil &#123;</div><div class="line">		mux.m = make(map[string]muxEntry)</div><div class="line">	&#125;</div><div class="line">       / / 创建 `muxEntry` 并添加到路由字典中</div><div class="line">	mux.m[pattern] = muxEntry&#123;explicit: <span class="literal">true</span>, h: handler, pattern: pattern&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> pattern[0] != <span class="string">'/'</span> &#123;</div><div class="line">		mux.hosts = <span class="literal">true</span></div><div class="line">	&#125;</div><div class="line">// 这是一个很有用的小技巧，如果注册了 `/tree/`， `serveMux` 会自动添加一个 `/tree` 的路径并重定向到 `/tree/`。当然这个 `/tree` 路径会被用户显示的路由信息覆盖。</div><div class="line">	// Helpful behavior:</div><div class="line">	// If pattern is /tree/, insert an implicit permanent redirect <span class="keyword">for</span> /tree.</div><div class="line">	// It can be overridden by an explicit registration.</div><div class="line">	n := len(pattern)</div><div class="line">	<span class="keyword">if</span> n &gt; 0 &amp;&amp; pattern[n-1] == <span class="string">'/'</span> &amp;&amp; !mux.m[pattern[0:n-1]].explicit &#123;</div><div class="line">		// If pattern contains a host name, strip it and use remaining</div><div class="line">		// path <span class="keyword">for</span> redirect.</div><div class="line">		path := pattern</div><div class="line">		<span class="keyword">if</span> pattern[0] != <span class="string">'/'</span> &#123;</div><div class="line">			// In pattern, at least the last character is a <span class="string">'/'</span>, so</div><div class="line">			// strings.Index can<span class="string">'t be -1.</span></div><div class="line"><span class="string">			path = pattern[strings.Index(pattern, "/"):]</span></div><div class="line"><span class="string">		&#125;</span></div><div class="line"><span class="string">		url := &amp;url.URL&#123;Path: path&#125;</span></div><div class="line"><span class="string">//注意最后一段代码对类似 /tree URL 重定向的处理。</span></div><div class="line"><span class="string">		mux.m[pattern[0:n-1]] = muxEntry&#123;h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern&#125;</span></div><div class="line"><span class="string">	&#125;</span></div><div class="line"><span class="string">&#125;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">// Does path match pattern?</div><div class="line">func pathMatch(pattern, path string) bool &#123;</div><div class="line">	<span class="keyword">if</span> len(pattern) == 0 &#123;</div><div class="line">		// should not happen</div><div class="line">		<span class="built_in">return</span> <span class="literal">false</span></div><div class="line">	&#125;</div><div class="line">	n := len(pattern)</div><div class="line">	<span class="keyword">if</span> pattern[n-1] != <span class="string">'/'</span> &#123;</div><div class="line">		<span class="built_in">return</span> pattern == path</div><div class="line">	&#125;</div><div class="line">    // 匹配的逻辑很简单，path 前面的字符和 pattern 一样就是匹配</div><div class="line">	<span class="built_in">return</span> len(path) &gt;= n &amp;&amp; path[0:n] == pattern</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Find a handler on a handler map given a path string</div><div class="line">// Most-specific (longest) pattern wins</div><div class="line">func (mux *ServeMux) match(path string) (h Handler, pattern string) &#123;</div><div class="line">	var n = 0</div><div class="line">	<span class="keyword">for</span> k, v := range mux.m &#123;</div><div class="line">		<span class="keyword">if</span> !pathMatch(k, path) &#123;</div><div class="line">			<span class="built_in">continue</span></div><div class="line">		&#125;</div><div class="line">         // 最长匹配的逻辑在这里</div><div class="line">		<span class="keyword">if</span> h == nil || len(k) &gt; n &#123;</div><div class="line">			n = len(k)</div><div class="line">			h = v.h</div><div class="line">			pattern = v.pattern</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>match</code>会遍历路由信息字典，找到所有匹配该路径最长的那个。路由部分的代码解释就到这里了，最后回答上面的一个问题：<code>http.HandleFunc</code> 和 <code>ServeMux.HandlerFunc</code>是什么关系？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// Handle registers the handler <span class="keyword">for</span> the given pattern</div><div class="line">// <span class="keyword">in</span> the DefaultServeMux.</div><div class="line">// The documentation <span class="keyword">for</span> ServeMux explains how patterns are matched.</div><div class="line">func Handle(pattern string, handler Handler) &#123; DefaultServeMux.Handle(pattern, handler) &#125;</div><div class="line"></div><div class="line">// HandleFunc registers the handler <span class="keyword">function</span> <span class="keyword">for</span> the given pattern</div><div class="line">// <span class="keyword">in</span> the DefaultServeMux.</div><div class="line">// The documentation <span class="keyword">for</span> ServeMux explains how patterns are matched.</div><div class="line">func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) &#123;</div><div class="line">	DefaultServeMux.HandleFunc(pattern, handler)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>原来是直接通过 DefaultServeMux 调用对应的方法</p>
<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>最后一部分，要讲讲 Handler 函数接受的两个参数：<code>http.Request</code> 和 <code>http.ResponseWriter</code>。<br>Request 就是封装好的客户端请求，包括 URL，method，header 等等所有信息.</p>
<h3 id="ResponseWriter"><a href="#ResponseWriter" class="headerlink" title="ResponseWriter"></a>ResponseWriter</h3><p>ResponseWriter 是一个接口，定义了三个方法：</p>
<ul>
<li><code>Header()</code>：返回一个 Header 对象，可以通过它的<code>Set()</code>方法设置头部，注意最终返回的头部信息可能和你写进去的不完全相同，因为后续处理还可能修改头部的值（比如设置 Content-Length、Content-type 等操作）</li>
<li><code>Write()</code>： 写 response 的主体部分，比如 html 或者 json 的内容就是放到这里的</li>
<li><code>WriteHeader()</code>：设置 status code，如果没有调用这个函数，默认设置为 http.StatusOK， 就是 200 状态码<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// A ResponseWriter interface is used by an HTTP handler to</div><div class="line">// construct an HTTP response.</div><div class="line"><span class="built_in">type</span> ResponseWriter interface &#123;</div><div class="line">	// Header returns the header map that will be sent by WriteHeader.</div><div class="line">	// Changing the header after a call to WriteHeader (or Write) has</div><div class="line">	// no effect.</div><div class="line">	Header() Header</div><div class="line">	// Write writes the data to the connection as part of an HTTP reply.</div><div class="line">	// If WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK)</div><div class="line">	// before writing the data.  If the Header does not contain a</div><div class="line">	// Content-Type line, Write adds a Content-Type <span class="built_in">set</span> to the result of passing</div><div class="line">	// the initial 512 bytes of written data to DetectContentType.</div><div class="line">	Write([]byte) (int, error)</div><div class="line"></div><div class="line">	// WriteHeader sends an HTTP response header with status code.</div><div class="line">	// If WriteHeader is not called explicitly, the first call to Write</div><div class="line">	// will trigger an implicit WriteHeader(http.StatusOK).</div><div class="line">	// Thus explicit calls to WriteHeader are mainly used to</div><div class="line">	// send error codes.</div><div class="line">	WriteHeader(int)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>实际上传递给 Handler 的对象是:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/ A response represents the server side of an HTTP response.</div><div class="line"><span class="built_in">type</span> response struct &#123;</div><div class="line">	conn          *conn</div><div class="line">	req           *Request // request <span class="keyword">for</span> this response</div><div class="line">	wroteHeader   bool     // reply header has been (logically) written</div><div class="line">	wroteContinue bool     // 100 Continue response was written</div><div class="line"></div><div class="line">	w  *bufio.Writer // buffers output <span class="keyword">in</span> chunks to chunkWriter</div><div class="line">	cw chunkWriter</div><div class="line">	sw *switchWriter // of the bufio.Writer, <span class="keyword">for</span> <span class="built_in">return</span> to putBufioWriter</div><div class="line"></div><div class="line">	// handlerHeader is the Header that Handlers get access to,</div><div class="line">	// <span class="built_in">which</span> may be retained and mutated even after WriteHeader.</div><div class="line">	// handlerHeader is copied into cw.header at WriteHeader</div><div class="line">	// time, and privately mutated thereafter.</div><div class="line">	handlerHeader Header</div><div class="line">	...</div><div class="line">	status        int   // status code passed to WriteHeader</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://cizixs.com/2016/08/17/golang-http-server-side" target="_blank" rel="external">go http 服务器编程</a></li>
</ul>

      
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2018/01/03/网络编程/">网络编程</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 glamor 的个人博客">glamor</a></p>
        <p><span>发布时间:</span>2018年01月03日 - 21时20分</p>
        <p><span>最后更新:</span>2018年01月03日 - 08时20分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2018/01/03/网络编程/" title="网络编程">http://www.cmustarc.com/2018/01/03/网络编程/</a>
            <span class="copy-path" data-clipboard-text="原文: http://www.cmustarc.com/2018/01/03/网络编程/　　作者: glamor" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a href="/2018/01/06/JSON处理/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          JSON处理
        
      </div>
    </a>
  
  
    <a href="/2018/01/02/windows采用命令/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">常用的windows命令</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#socket编程"><span class="toc-number">1.</span> <span class="toc-text">socket编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Dial-函数"><span class="toc-number">1.1.</span> <span class="toc-text">Dial()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP连接"><span class="toc-number">1.1.1.</span> <span class="toc-text">TCP连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP连接"><span class="toc-number">1.1.2.</span> <span class="toc-text">UDP连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ICMP连接"><span class="toc-number">1.1.3.</span> <span class="toc-text">ICMP连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP示例程序"><span class="toc-number">1.2.</span> <span class="toc-text">TCP示例程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展"><span class="toc-number">1.3.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简单示例"><span class="toc-number">1.3.1.</span> <span class="toc-text">简单示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP编程"><span class="toc-number">2.</span> <span class="toc-text">HTTP编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本方法"><span class="toc-number">2.1.</span> <span class="toc-text">基本方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#http-Get"><span class="toc-number">2.1.1.</span> <span class="toc-text">http.Get()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-Post"><span class="toc-number">2.1.2.</span> <span class="toc-text">http.Post()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-PostForm"><span class="toc-number">2.1.3.</span> <span class="toc-text">http.PostForm()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-Head"><span class="toc-number">2.1.4.</span> <span class="toc-text">http.Head()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-Client-Do"><span class="toc-number">2.1.5.</span> <span class="toc-text">(*http.Client).Do()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#高级封装"><span class="toc-number">2.2.</span> <span class="toc-text">高级封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义http-Transport"><span class="toc-number">2.2.1.</span> <span class="toc-text">自定义http.Transport</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-RoundTripper接口"><span class="toc-number">2.2.2.</span> <span class="toc-text">http.RoundTripper接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP服务端"><span class="toc-number">3.</span> <span class="toc-text">HTTP服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#封装"><span class="toc-number">3.1.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用的Handler"><span class="toc-number">3.2.</span> <span class="toc-text">常用的Handler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#路由"><span class="toc-number">3.3.</span> <span class="toc-text">路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#深入"><span class="toc-number">3.4.</span> <span class="toc-text">深入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Server"><span class="toc-number">3.4.1.</span> <span class="toc-text">Server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ServeMux"><span class="toc-number">3.4.2.</span> <span class="toc-text">ServeMux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Request"><span class="toc-number">3.4.3.</span> <span class="toc-text">Request</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ResponseWriter"><span class="toc-number">3.4.4.</span> <span class="toc-text">ResponseWriter</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol>
</div>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
    }
</script>





<div class="bdsharebuttonbox">
	<a href="#" class="fx fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="fx fa-weixin bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="fx fa-qq bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
	<a href="#" class="fx fa-facebook-official bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="fx fa-twitter bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="fx fa-linkedin bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
	<a href="#" class="fx fa-files-o bds_copy" data-cmd="copy" title="分享到复制网址"></a>
</div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>




    



    <div class="scroll" id="post-nav-button">
        
            <a href="/2018/01/06/JSON处理/" title="上一篇: JSON处理">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/2018/01/02/windows采用命令/" title="下一篇: 常用的windows命令">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/05/28/python-importlib/">importlib动态加载模块</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/27/某扫描器/">某扫描器</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/27/惊蛰漏洞扫描平台分析/">惊蛰漏洞扫描平台分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/07/加密/">加密</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/06/JSON处理/">JSON处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/03/网络编程/">网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/02/windows采用命令/">常用的windows命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/31/byte与rune/">rune与byte</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/28/数组与字典/">数组与数组切片</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/15/Python3笔记/">Python3 学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/03/python基础/">python基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/07/数据链路层/">数据链路</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/01/网络基础/">网络基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/01/tcp-ip简介/">tcp/ip简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/24/HTMLParser模块/">HTMLParser模块</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/23/SQL注入/">SQL注入整理(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/20/列表/">列表</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/19/偏函数/">偏函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/18/with上下文管理器/">上下文管理器与with语句</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/13/v2ray/">v2ray 配置文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/29/socket-python/">socket编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/28/正则表达式/">正则表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/15/s2-053/">S2-053</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/golang流程控制/">流程控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/Strut2 常见POC/">Struts2 常见POC收集和整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/论事件驱动与异步IO/">论事件驱动与异步IO[转]</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/并发编程/">并发编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/Python常用模块2/">python常用模块(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/Python常用模块/">python常用模块(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/python TCP代理/">python TCP代理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/hexo+github+nginx VPS搭建博客/">hexo+github+nginx vps搭建博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/go语言初识/">初识go语言</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/goroutine与调度器/">goroutine与调度器[转]</a></li></ul>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
            }
        })
    </script>



    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2018 glamor
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/luuman/hexo-theme-spfk" target="_blank">spfk</a> by luuman
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >道士到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>论事件驱动与异步IO[转] | Merak的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="转载自人云思云 同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。 本文讨论的背景是Linux环境下的network IO">
<meta name="keywords" content="事件驱动,异步IO">
<meta property="og:type" content="article">
<meta property="og:title" content="论事件驱动与异步IO[转]">
<meta property="og:url" content="http://www.Merak.cc/2017/09/05/论事件驱动与异步IO/index.html">
<meta property="og:site_name" content="Merak的博客">
<meta property="og:description" content="转载自人云思云 同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。 本文讨论的背景是Linux环境下的network IO">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://img.blog.csdn.net/20161014202755008">
<meta property="og:image" content="http://img.blog.csdn.net/20161014202857223">
<meta property="og:image" content="http://img.blog.csdn.net/20161014202917364">
<meta property="og:image" content="http://img.blog.csdn.net/20161014203031995">
<meta property="og:image" content="http://img.blog.csdn.net/20161014203153559">
<meta property="og:updated_time" content="2017-09-05T07:02:28.067Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="论事件驱动与异步IO[转]">
<meta name="twitter:description" content="转载自人云思云 同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。 本文讨论的背景是Linux环境下的network IO">
<meta name="twitter:image" content="http://img.blog.csdn.net/20161014202755008">
  
    <link rel="alternative" href="/atom.xml" title="Merak的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate">Merak</a></h1>
        </hgroup>

        
        <p class="header-subtitle">莫等闲，白了少年头空悲切...</p>
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">博客首页</a></li>
                        
                            <li><a href="/categories/python">人生苦短</a></li>
                        
                            <li><a href="/categories/Web安全">安全海洋</a></li>
                        
                            <li><a href="/categories/notes">随笔</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="mailto:root@cmustard.com" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/cmustard06" title="github">github</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/PHP/" style="font-size: 10px;">PHP</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP/IP</a> <a href="/tags/go/" style="font-size: 10px;">go</a> <a href="/tags/golang/" style="font-size: 17.5px;">golang</a> <a href="/tags/importlib/" style="font-size: 10px;">importlib</a> <a href="/tags/poc/" style="font-size: 12.5px;">poc</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/python3/" style="font-size: 12.5px;">python3</a> <a href="/tags/sql注入/" style="font-size: 10px;">sql注入</a> <a href="/tags/struct/" style="font-size: 10px;">struct</a> <a href="/tags/struts/" style="font-size: 10px;">struts</a> <a href="/tags/tcp/" style="font-size: 10px;">tcp</a> <a href="/tags/tcp-ip/" style="font-size: 10px;">tcp/ip</a> <a href="/tags/windows命令/" style="font-size: 10px;">windows命令</a> <a href="/tags/事件驱动/" style="font-size: 10px;">事件驱动</a> <a href="/tags/代理/" style="font-size: 10px;">代理</a> <a href="/tags/博客/" style="font-size: 10px;">博客</a> <a href="/tags/基础/" style="font-size: 15px;">基础</a> <a href="/tags/安全/" style="font-size: 10px;">安全</a> <a href="/tags/并发/" style="font-size: 10px;">并发</a> <a href="/tags/异步IO/" style="font-size: 10px;">异步IO</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/漏扫/" style="font-size: 12.5px;">漏扫</a> <a href="/tags/爬虫/" style="font-size: 10px;">爬虫</a> <a href="/tags/科学上网/" style="font-size: 10px;">科学上网</a> <a href="/tags/系统/" style="font-size: 10px;">系统</a> <a href="/tags/编程/" style="font-size: 15px;">编程</a> <a href="/tags/编程语言/" style="font-size: 12.5px;">编程语言</a> <a href="/tags/网络/" style="font-size: 12.5px;">网络</a> <a href="/tags/网络基础知识/" style="font-size: 10px;">网络基础知识</a> <a href="/tags/网络编程/" style="font-size: 10px;">网络编程</a> <a href="/tags/集合/" style="font-size: 10px;">集合</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.dmmjy9.top">dmmjy9</a>
                    
                    </div>
                </section>
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">Merak</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">Merak</a></h1>
            </hgroup>
            
            <p class="header-subtitle">莫等闲，白了少年头空悲切...</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">博客首页</a></li>
                
                    <li><a href="/categories/python">人生苦短</a></li>
                
                    <li><a href="/categories/Web安全">安全海洋</a></li>
                
                    <li><a href="/categories/notes">随笔</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="mailto:root@cmustard.com" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/cmustard06" title="github">github</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-论事件驱动与异步IO" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/05/论事件驱动与异步IO/" class="article-date">
      <time datetime="2017-09-05T07:02:28.067Z" itemprop="datePublished">2017-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      论事件驱动与异步IO[转]
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/notes/">notes</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/事件驱动/">事件驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步IO/">异步IO</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>转载自<a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="external">人云思云</a></p>
<p>同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。</p>
<p><em>本文讨论的背景是Linux环境下的network IO</em><br><a id="more"></a></p>
<h1 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h1><p>在进行解释之前，首先要说明几个概念：</p>
<ul>
<li>用户空间和内核空间</li>
<li>进程切换</li>
<li>进程的阻塞</li>
<li>文件描述符</li>
<li>缓存 I/O</li>
</ul>
<h2 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h2><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
<h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>
<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p>
<ol>
<li>保存处理机上下文，包括程序计数器和其他寄存器。</li>
<li>更新PCB信息。</li>
<li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li>
<li>选择另一个进程执行，并更新其PCB。</li>
<li>更新内存管理的数据结构。</li>
<li>恢复处理机上下文。<br>注：总而言之就是很耗资源，具体的可以参考这篇文章：<a href="http://guojing.me/linux-kernel-architecture/posts/process-switch/" target="_blank" rel="external">进程切换</a></li>
</ol>
<h2 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h2><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的</p>
<h2 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h2><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<h2 id="缓存-I-O"><a href="#缓存-I-O" class="headerlink" title="缓存 I/O"></a>缓存 I/O</h2><p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>
<p>缓存 I/O 的缺点：<br>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
<h1 id="IO模式"><a href="#IO模式" class="headerlink" title="IO模式"></a>IO模式</h1><p>刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p>
<ol>
<li>等待数据准备 (Waiting for the data to be ready)</li>
<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
</ol>
<p>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。</p>
<ul>
<li>阻塞 I/O（blocking IO）</li>
<li>非阻塞 I/O（nonblocking IO）</li>
<li>I/O 多路复用（ IO multiplexing）</li>
<li>信号驱动 I/O（ signal driven IO）</li>
<li>异步 I/O（asynchronous IO）</li>
</ul>
<p>注：由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。</p>
<h2 id="阻塞-I-O（blocking-IO）"><a href="#阻塞-I-O（blocking-IO）" class="headerlink" title="阻塞 I/O（blocking IO）"></a>阻塞 I/O（blocking IO）</h2><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：<br><img src="http://img.blog.csdn.net/20161014202755008" alt="这里写图片描述"></p>
<p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</div></pre></td></tr></table></figure>
<h2 id="非阻塞-I-O（nonblocking-IO）"><a href="#非阻塞-I-O（nonblocking-IO）" class="headerlink" title="非阻塞 I/O（nonblocking IO）"></a>非阻塞 I/O（nonblocking IO）</h2><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：<br><img src="http://img.blog.csdn.net/20161014202857223" alt="这里写图片描述"><br>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</div></pre></td></tr></table></figure>
<h2 id="I-O-多路复用（-IO-multiplexing）"><a href="#I-O-多路复用（-IO-multiplexing）" class="headerlink" title="I/O 多路复用（ IO multiplexing）"></a>I/O 多路复用（ IO multiplexing）</h2><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。<br><img src="http://img.blog.csdn.net/20161014202917364" alt="这里写图片描述"></p>
<p><strong>当用户进程调用了select，那么整个进程会被block</strong>，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，</div><div class="line">而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，</div><div class="line">select()函数就可以返回。</div></pre></td></tr></table></figure>
<p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<h2 id="异步-I-O（asynchronous-IO）"><a href="#异步-I-O（asynchronous-IO）" class="headerlink" title="异步 I/O（asynchronous IO）"></a>异步 I/O（asynchronous IO）</h2><p>inux下的asynchronous IO其实用得很少。先看一下它的流程：<br><img src="http://img.blog.csdn.net/20161014203031995" alt="这里写图片描述"><br>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="blocking和non-blocking的区别"><a href="#blocking和non-blocking的区别" class="headerlink" title="blocking和non-blocking的区别"></a>blocking和non-blocking的区别</h3><p>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p>
<h3 id="synchronous-IO和asynchronous-IO的区别"><a href="#synchronous-IO和asynchronous-IO的区别" class="headerlink" title="synchronous IO和asynchronous IO的区别"></a>synchronous IO和asynchronous IO的区别</h3><p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：</p>
<ul>
<li>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</li>
<li>An asynchronous I/O operation does not cause the requesting process to be blocked;</li>
</ul>
<p>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p>
<p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p>
<p>而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p>
<p>各个IO Model的比较如图所示：<br><img src="http://img.blog.csdn.net/20161014203153559" alt="这里写图片描述"></p>
<p>通过上面的图片，可以发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>
<h1 id="I-O-多路复用之select、poll、epoll详解"><a href="#I-O-多路复用之select、poll、epoll详解" class="headerlink" title="I/O 多路复用之select、poll、epoll详解"></a>I/O 多路复用之select、poll、epoll详解</h1><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</div></pre></td></tr></table></figure>
<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。</p>
<p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int poll (struct pollfd *fds, unsigned int nfds, int timeout);</div></pre></td></tr></table></figure>
<p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct pollfd &#123;</div><div class="line">    int fd; /* file descriptor */</div><div class="line">    short events; /* requested events to watch */</div><div class="line">    short revents; /* returned events witnessed */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。</div><div class="line">事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，</div><div class="line">因此随着监视的描述符数量的增长，其效率也会线性下降。</div></pre></td></tr></table></figure>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>
<h3 id="epoll操作过程"><a href="#epoll操作过程" class="headerlink" title="epoll操作过程"></a>epoll操作过程</h3><p>epoll操作过程需要三个接口，分别如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</div><div class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</div><div class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</div></pre></td></tr></table></figure>
<p><strong>int epoll_create(int size);</strong><br>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。<br>当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
<p><strong>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</strong><br>函数是对指定描述符fd执行op操作。</p>
<ul>
<li>epfd：是epoll_create()的返回值。</li>
<li>op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</li>
<li>fd：是需要监听的fd（文件描述符）</li>
<li>epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct epoll_event &#123;</div><div class="line">  __uint32_t events;  /* Epoll events */</div><div class="line">  epoll_data_t data;  /* User data variable */</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//events可以是以下几个宏的集合：</div><div class="line">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</div><div class="line">EPOLLOUT：表示对应的文件描述符可以写；</div><div class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</div><div class="line">EPOLLERR：表示对应的文件描述符发生错误；</div><div class="line">EPOLLHUP：表示对应的文件描述符被挂断；</div><div class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</div><div class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</div></pre></td></tr></table></figure>
<p><strong>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</strong><br>等待epfd上的io事件，最多返回maxevents个事件。<br>参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：<br>　　LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>　　ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
<h4 id="LT模式"><a href="#LT模式" class="headerlink" title="LT模式"></a>LT模式</h4><p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<h4 id="ET模式"><a href="#ET模式" class="headerlink" title="ET模式"></a>ET模式</h4><p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>
<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>假如有这样一个例子：</p>
<ol>
<li>我们已经把一个用来从管道中读取数据的文件句柄(RFD)添加到epoll描述符</li>
<li>这个时候从管道的另一端被写入了2KB的数据</li>
<li>调用epoll_wait(2)，并且它会返回RFD，说明它已经准备好读取操作</li>
<li>然后我们读取了1KB的数据</li>
<li>调用epoll_wait(2)……</li>
</ol>
<p>LT模式：<br>如果是LT模式，那么在第5步调用epoll_wait(2)之后，仍然能受到通知。</p>
<p>ET模式：<br>如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait(2)之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。</p>
<p>当使用epoll的ET模型来工作时，当产生了一个EPOLLIN事件后， 读数据的时候需要考虑的是当recv()返回的大小如果等于请求的大小，那么很有可能是缓冲区还有数据未读完，也意味着该次事件还没有处理完，所以还需要再次读取：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(rs)&#123;</div><div class="line">  buflen = recv(activeevents[i].data.fd, buf, sizeof(buf), 0);</div><div class="line">  <span class="keyword">if</span>(buflen &lt; 0)&#123;</div><div class="line">    // 由于是非阻塞的模式,所以当errno为EAGAIN时,表示当前缓冲区已无数据可读</div><div class="line">    // 在这里就当作是该次事件已处理处.</div><div class="line">    <span class="keyword">if</span>(errno == EAGAIN)&#123;</div><div class="line">        <span class="built_in">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">return</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(buflen == 0)&#123;</div><div class="line">     // 这里表示对端的socket已正常关闭.</div><div class="line">  &#125;</div><div class="line"></div><div class="line"> <span class="keyword">if</span>(buflen == sizeof(buf)&#123;</div><div class="line">      rs = 1;   // 需要再次读取</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">else</span>&#123;</div><div class="line">      rs = 0;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Linux中的EAGAIN含义"><a href="#Linux中的EAGAIN含义" class="headerlink" title="Linux中的EAGAIN含义"></a><strong>Linux中的EAGAIN含义</strong></h4><p>Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。 从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。</p>
<p>例如，以 O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。 又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。</p>
<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>下面是一段不完整的代码且格式不对，意在表述上面的过程，去掉了一些模板代码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#define IPADDRESS   "127.0.0.1"</span></div><div class="line"><span class="comment">#define PORT        8787</span></div><div class="line"><span class="comment">#define MAXSIZE     1024</span></div><div class="line"><span class="comment">#define LISTENQ     5</span></div><div class="line"><span class="comment">#define FDSIZE      1000</span></div><div class="line"><span class="comment">#define EPOLLEVENTS 100</span></div><div class="line"></div><div class="line">listenfd = socket_bind(IPADDRESS,PORT);</div><div class="line"></div><div class="line">struct epoll_event events[EPOLLEVENTS];</div><div class="line"></div><div class="line">//创建一个描述符</div><div class="line">epollfd = epoll_create(FDSIZE);</div><div class="line"></div><div class="line">//添加监听描述符事件</div><div class="line">add_event(epollfd,listenfd,EPOLLIN);</div><div class="line"></div><div class="line">//循环等待</div><div class="line"><span class="keyword">for</span> ( ; ; )&#123;</div><div class="line">    //该函数返回已经准备好的描述符事件数目</div><div class="line">    ret = epoll_wait(epollfd,events,EPOLLEVENTS,-1);</div><div class="line">    //处理接收到的连接</div><div class="line">    handle_events(epollfd,events,ret,listenfd,buf);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//事件处理函数</div><div class="line">static void handle_events(int epollfd,struct epoll_event *events,int num,int listenfd,char *buf)</div><div class="line">&#123;</div><div class="line">     int i;</div><div class="line">     int fd;</div><div class="line">     //进行遍历;这里只要遍历已经准备好的io事件。num并不是当初epoll_create时的FDSIZE。</div><div class="line">     <span class="keyword">for</span> (i = 0;i &lt; num;i++)</div><div class="line">     &#123;</div><div class="line">         fd = events[i].data.fd;</div><div class="line">        //根据描述符的类型和事件类型进行处理</div><div class="line">         <span class="keyword">if</span> ((fd == listenfd) &amp;&amp;(events[i].events &amp; EPOLLIN))</div><div class="line">            handle_accpet(epollfd,listenfd);</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</div><div class="line">            do_read(epollfd,fd,buf);</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</div><div class="line">            do_write(epollfd,fd,buf);</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//添加事件</div><div class="line">static void add_event(int epollfd,int fd,int state)&#123;</div><div class="line">    struct epoll_event ev;</div><div class="line">    ev.events = state;</div><div class="line">    ev.data.fd = fd;</div><div class="line">    epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;ev);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//处理接收到的连接</div><div class="line">static void handle_accpet(int epollfd,int listenfd)&#123;</div><div class="line">     int clifd;     </div><div class="line">     struct sockaddr_in cliaddr;     </div><div class="line">     socklen_t  cliaddrlen;     </div><div class="line">     clifd = accept(listenfd,(struct sockaddr*)&amp;cliaddr,&amp;cliaddrlen);     </div><div class="line">     <span class="keyword">if</span> (clifd == -1)         </div><div class="line">     perror(<span class="string">"accpet error:"</span>);     </div><div class="line">     <span class="keyword">else</span> &#123;         </div><div class="line">         <span class="built_in">printf</span>(<span class="string">"accept a new client: %s:%d\n"</span>,inet_ntoa(cliaddr.sin_addr),cliaddr.sin_port);                       //添加一个客户描述符和事件         </div><div class="line">         add_event(epollfd,clifd,EPOLLIN);     </div><div class="line">     &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line">//读处理</div><div class="line">static void do_read(int epollfd,int fd,char *buf)&#123;</div><div class="line">    int nread;</div><div class="line">    nread = <span class="built_in">read</span>(fd,buf,MAXSIZE);</div><div class="line">    <span class="keyword">if</span> (nread == -1)     &#123;         </div><div class="line">        perror(<span class="string">"read error:"</span>);         </div><div class="line">        close(fd); //记住close fd        </div><div class="line">        delete_event(epollfd,fd,EPOLLIN); //删除监听 </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nread == 0)     &#123;         </div><div class="line">        fprintf(stderr,<span class="string">"client close.\n"</span>);</div><div class="line">        close(fd); //记住close fd       </div><div class="line">        delete_event(epollfd,fd,EPOLLIN); //删除监听 </div><div class="line">    &#125;     </div><div class="line">    <span class="keyword">else</span> &#123;         </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"read message is : %s"</span>,buf);        </div><div class="line">        //修改描述符对应的事件，由读改为写         </div><div class="line">        modify_event(epollfd,fd,EPOLLOUT);     </div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line">//写处理</div><div class="line">static void do_write(int epollfd,int fd,char *buf) &#123;     </div><div class="line">    int nwrite;     </div><div class="line">    nwrite = write(fd,buf,strlen(buf));     </div><div class="line">    <span class="keyword">if</span> (nwrite == -1)&#123;         </div><div class="line">        perror(<span class="string">"write error:"</span>);        </div><div class="line">        close(fd);   //记住close fd       </div><div class="line">        delete_event(epollfd,fd,EPOLLOUT);  //删除监听    </div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        modify_event(epollfd,fd,EPOLLIN); </div><div class="line">    &#125;    </div><div class="line">    memset(buf,0,MAXSIZE); </div><div class="line">&#125;</div><div class="line"></div><div class="line">//删除事件</div><div class="line">static void delete_event(int epollfd,int fd,int state) &#123;</div><div class="line">    struct epoll_event ev;</div><div class="line">    ev.events = state;</div><div class="line">    ev.data.fd = fd;</div><div class="line">    epoll_ctl(epollfd,EPOLL_CTL_DEL,fd,&amp;ev);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//修改事件</div><div class="line">static void modify_event(int epollfd,int fd,int state)&#123;     </div><div class="line">    struct epoll_event ev;</div><div class="line">    ev.events = state;</div><div class="line">    ev.data.fd = fd;</div><div class="line">    epoll_ctl(epollfd,EPOLL_CTL_MOD,fd,&amp;ev);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//注：另外一端我就省了</div></pre></td></tr></table></figure>
<h3 id="epoll总结"><a href="#epoll总结" class="headerlink" title="epoll总结"></a>epoll总结</h3><p>在 select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知。(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。)</p>
<p>epoll的优点主要是一下几个方面：</p>
<ol>
<li>监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。select的最大缺点就是进程打开的fd是有数量限制的。这对 于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache就是这样实现的)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。</li>
</ol>
<p>IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数</p>
<p>参考<br><a rel="external" href="http://www.cnblogs.com/Anker/p/3269106.html" target="_blank">用户空间与内核空间，进程上下文与中断上下文[总结]</a><br><a rel="external" href="http://guojing.me/linux-kernel-architecture/posts/process-switch/" target="_blank">进程切换</a><br><a rel="external" href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6" target="_blank">维基百科-文件描述符</a><br><a rel="external" href="http://www.ibm.com/developerworks/cn/linux/l-cn-directio/" target="_blank">Linux 中直接 I/O 机制的介绍</a><br><a rel="external" href="http://blog.csdn.net/historyasamirror/article/details/5778378" target="_blank">IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）</a><br><a rel="external" href="http://www.cnblogs.com/bigwangdi/p/3182958.html" target="_blank">Linux中select poll和epoll的区别</a><br><a rel="external" href="http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html" target="_blank">IO多路复用之select总结</a><br><a rel="external" href="http://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html" target="_blank">IO多路复用之poll总结</a><br><a rel="external" href="http://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html" target="_blank">IO多路复用之epoll总结</a></p><p></p>

      
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2017/09/05/论事件驱动与异步IO/">论事件驱动与异步IO[转]</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 Merak 的个人博客">Merak</a></p>
        <p><span>发布时间:</span>2017年09月05日 - 15时02分</p>
        <p><span>最后更新:</span>2017年09月05日 - 03时02分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2017/09/05/论事件驱动与异步IO/" title="论事件驱动与异步IO[转]">http://www.Merak.cc/2017/09/05/论事件驱动与异步IO/</a>
            <span class="copy-path" data-clipboard-text="原文: http://www.Merak.cc/2017/09/05/论事件驱动与异步IO/　　作者: Merak" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a href="/2017/09/10/Strut2 常见POC/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Struts2 常见POC收集和整理
        
      </div>
    </a>
  
  
    <a href="/2017/09/05/并发编程/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">并发编程</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概念说明"><span class="toc-number">1.</span> <span class="toc-text">概念说明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#用户空间与内核空间"><span class="toc-number">1.1.</span> <span class="toc-text">用户空间与内核空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程切换"><span class="toc-number">1.2.</span> <span class="toc-text">进程切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程的阻塞"><span class="toc-number">1.3.</span> <span class="toc-text">进程的阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件描述符fd"><span class="toc-number">1.4.</span> <span class="toc-text">文件描述符fd</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缓存-I-O"><span class="toc-number">1.5.</span> <span class="toc-text">缓存 I/O</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO模式"><span class="toc-number">2.</span> <span class="toc-text">IO模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞-I-O（blocking-IO）"><span class="toc-number">2.1.</span> <span class="toc-text">阻塞 I/O（blocking IO）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非阻塞-I-O（nonblocking-IO）"><span class="toc-number">2.2.</span> <span class="toc-text">非阻塞 I/O（nonblocking IO）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O-多路复用（-IO-multiplexing）"><span class="toc-number">2.3.</span> <span class="toc-text">I/O 多路复用（ IO multiplexing）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步-I-O（asynchronous-IO）"><span class="toc-number">2.4.</span> <span class="toc-text">异步 I/O（asynchronous IO）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">2.5.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#blocking和non-blocking的区别"><span class="toc-number">2.5.1.</span> <span class="toc-text">blocking和non-blocking的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronous-IO和asynchronous-IO的区别"><span class="toc-number">2.5.2.</span> <span class="toc-text">synchronous IO和asynchronous IO的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#I-O-多路复用之select、poll、epoll详解"><span class="toc-number">3.</span> <span class="toc-text">I/O 多路复用之select、poll、epoll详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#select"><span class="toc-number">3.1.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#poll"><span class="toc-number">3.2.</span> <span class="toc-text">poll</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#epoll"><span class="toc-number">3.3.</span> <span class="toc-text">epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll操作过程"><span class="toc-number">3.3.1.</span> <span class="toc-text">epoll操作过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工作模式"><span class="toc-number">3.3.2.</span> <span class="toc-text">工作模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LT模式"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">LT模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ET模式"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">ET模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结-1"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux中的EAGAIN含义"><span class="toc-number">3.3.2.4.</span> <span class="toc-text">Linux中的EAGAIN含义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码演示"><span class="toc-number">3.3.3.</span> <span class="toc-text">代码演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll总结"><span class="toc-number">3.3.4.</span> <span class="toc-text">epoll总结</span></a></li></ol></li></ol></li></ol>
</div>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
    }
</script>





<div class="bdsharebuttonbox">
	<a href="#" class="fx fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="fx fa-weixin bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="fx fa-qq bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
	<a href="#" class="fx fa-facebook-official bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="fx fa-twitter bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="fx fa-linkedin bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
	<a href="#" class="fx fa-files-o bds_copy" data-cmd="copy" title="分享到复制网址"></a>
</div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>




    



    <div class="scroll" id="post-nav-button">
        
            <a href="/2017/09/10/Strut2 常见POC/" title="上一篇: Struts2 常见POC收集和整理">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/2017/09/05/并发编程/" title="下一篇: 并发编程">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/24/死锁，活锁，饥饿/">死锁，活锁，饥饿</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/30/php序列化/">PHP序列化与反序列化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/28/python-importlib/">importlib动态加载模块</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/27/某扫描器/">某扫描器</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/27/惊蛰漏洞扫描平台分析/">惊蛰漏洞扫描平台分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/07/加密/">加密</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/06/JSON处理/">JSON处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/03/网络编程/">网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/02/windows采用命令/">常用的windows命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/31/byte与rune/">rune与byte</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/28/数组与字典/">数组与数组切片</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/15/Python3笔记/">Python3 学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/03/python基础/">python基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/07/数据链路层/">数据链路</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/01/网络基础/">网络基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/01/tcp-ip简介/">tcp/ip简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/24/HTMLParser模块/">HTMLParser模块</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/23/SQL注入/">SQL注入整理(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/20/列表/">列表</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/19/偏函数/">偏函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/18/with上下文管理器/">上下文管理器与with语句</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/13/v2ray/">v2ray 配置文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/29/socket-python/">socket编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/28/正则表达式/">正则表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/15/s2-053/">S2-053</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/golang流程控制/">流程控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/Strut2 常见POC/">Struts2 常见POC收集和整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/论事件驱动与异步IO/">论事件驱动与异步IO[转]</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/并发编程/">并发编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/Python常用模块2/">python常用模块(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/Python常用模块/">python常用模块(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/python TCP代理/">python TCP代理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/hexo+github+nginx VPS搭建博客/">hexo+github+nginx vps搭建博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/go语言初识/">初识go语言</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/goroutine与调度器/">goroutine与调度器[转]</a></li></ul>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
            }
        })
    </script>



    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2018 Merak
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/luuman/hexo-theme-spfk" target="_blank">spfk</a> by luuman
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >道士到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>